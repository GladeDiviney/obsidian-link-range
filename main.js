/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkRange
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// main.ts
var import_view3 = require("@codemirror/view");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/utils.ts
var path = __toESM(require("path"));
function parseHrefLink(href, settings) {
  const linkRegex = /([^#|]*)#?([^#|]*)?\|?(.*)?/;
  const matches = linkRegex.exec(href);
  if (matches == null || matches.length < 3 || matches[2] == void 0) {
    return null;
  }
  const note = matches[1];
  const partialPath = note + ".md";
  const basePart = path.basename(note);
  const file = app.vault.getMarkdownFiles().filter(
    (x) => x.basename == basePart && x.path.endsWith(partialPath)
  ).first();
  if (!file)
    return null;
  const pattern = findPatternForFile(file, settings);
  const split = matches[2].split(settings.headingSeparator);
  const h1 = split[0];
  const h2 = split[1];
  let altText = "";
  if (matches.length > 3 && matches[3] != void 0) {
    altText = matches[3];
  } else {
    const headingVisual = pattern.headingVisual === "" ? "#" : pattern.headingVisual;
    const headingSeparatorVisual = pattern.headingSeparatorVisual === "" ? settings.headingSeparator : pattern.headingSeparatorVisual;
    if (h2 !== void 0) {
      altText = `${basePart}${headingVisual}${h1}${headingSeparatorVisual}${h2}`;
    } else {
      altText = `${basePart}${headingVisual}${h1}`;
    }
  }
  return {
    note,
    h1,
    h2,
    altText,
    pattern,
    file,
    // Will find these later 
    h1Line: 0,
    h2Line: void 0
  };
}
function parseLink(app2, linkHTML, settings, isEmbed = false, hrefField = "data-href") {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const href = linkHTML.getAttribute(hrefField);
  if (href == null)
    return null;
  const res = parseHrefLink(href, settings);
  if (!res || app2.metadataCache == null)
    return null;
  const alt = linkHTML.getAttribute("alt");
  if (alt != null && !alt.contains(res.note)) {
    res.altText = alt;
  }
  if (!isEmbed && !linkHTML.innerText.contains(res.note)) {
    res.altText = linkHTML.innerText;
  }
  const meta = app2.metadataCache.getFileCache(res.file);
  if (meta == void 0 || meta.headings == void 0) {
    return null;
  }
  const h1Line = (_b = (_a = meta == null ? void 0 : meta.headings) == null ? void 0 : _a.filter(
    (h) => h.heading == res.h1
  ).first()) == null ? void 0 : _b.position.start.line;
  if (h1Line == void 0)
    return null;
  res.h1Line = h1Line;
  if (res.h2 !== void 0) {
    if (settings.endInclusive) {
      let h2LineIndex = (_c = meta == null ? void 0 : meta.headings) == null ? void 0 : _c.findIndex((h) => h.heading == res.h2);
      if (((_d = meta == null ? void 0 : meta.headings) == null ? void 0 : _d.length) > h2LineIndex) {
        h2LineIndex += 1;
      }
      res.h2Line = (_f = (_e = meta == null ? void 0 : meta.headings) == null ? void 0 : _e.at(h2LineIndex)) == null ? void 0 : _f.position.end.line;
    } else {
      res.h2Line = (_h = (_g = meta == null ? void 0 : meta.headings) == null ? void 0 : _g.filter(
        (h) => h.heading == res.h2
      ).first()) == null ? void 0 : _h.position.end.line;
    }
  }
  return res;
}
function postProcessorUpdate(app2) {
  for (const leaf of app2.workspace.getLeavesOfType("markdown")) {
    const view = leaf.view;
    view.previewMode.renderer.clear();
    view.previewMode.renderer.set(view.editor.cm.state.doc.toString());
  }
  app2.workspace.updateOptions();
}
function findPatternForFilename(fileName, settings) {
  const file = app.vault.getFiles().find((file2) => file2.basename === fileName);
  return findPatternForFile(file, settings);
}
function findPatternForFile(file, settings) {
  if (file) {
    let pattern = [...settings.patterns].reverse().find(
      (pattern2) => file.path.startsWith(pattern2.path)
    );
    if (pattern)
      return pattern;
  }
  return settings.getDefaultPattern();
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  headingSeparator: "..",
  endInclusive: true,
  altFormat: "",
  settingsVersion: "v2",
  patterns: [{ headingVisual: "..", headingSeparatorVisual: "-", path: "/" }],
  getDefaultPattern() {
    const first = this.patterns[0];
    if (!first) {
      return { headingVisual: ":", headingSeparatorVisual: "-", path: "/" };
    }
    return first;
  }
};
var LinkRangeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.migrateOldSettings();
  }
  migrateOldSettings() {
    const stgs = this.plugin.settings;
    const hasV1Settings = stgs.altFormat != void 0 && stgs.altFormat.length > 0;
    if (hasV1Settings) {
      const altFormat = stgs.altFormat;
      const indexOfNote = altFormat.indexOf("$note");
      const indexOfH1 = altFormat.indexOf("$h1");
      const indexOfH2 = altFormat.indexOf("$h2");
      const formatIsValid = indexOfNote === 0 && indexOfH1 !== -1 && indexOfH2 !== -2;
      if (formatIsValid) {
        const firstValue = altFormat.substring("$note".length, indexOfH1);
        const secondValue = altFormat.substring(indexOfH1 + "$h1".length, indexOfH2);
        stgs.patterns = [{ headingVisual: firstValue, headingSeparatorVisual: secondValue, path: "" }];
      }
      stgs.altFormat = "";
      this.plugin.saveSettings();
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.createH2("Settings for link-range plugin");
    new import_obsidian.Setting(containerEl).setName("Heading Separator").setDesc('Defines the separator to be used to define a link heading range. Defaults to ".." (e.g. [[Note Name#h1..h2]])').addText((text) => text.setPlaceholder("Enter a separator string (defaults to ..)").setValue(this.plugin.settings.headingSeparator).onChange(async (value) => {
      this.plugin.settings.headingSeparator = value;
      await this.plugin.saveSettings();
      postProcessorUpdate(this.app);
    }));
    new import_obsidian.Setting(containerEl).setName("End Inclusive").setDesc("Whether or not the end heading should be inclusive or exclusive").addToggle((bool) => bool.setValue(this.plugin.settings.endInclusive).onChange(async (value) => {
      this.plugin.settings.endInclusive = value;
      await this.plugin.saveSettings();
      postProcessorUpdate(this.app);
    }));
    new import_obsidian.Setting(this.containerEl).setName("Add a New Visual Pattern").setDesc("Add new pattern to match files in a directory. The first value will change the visual for the heading in a link. The second value will change the visual for separator. The third specifies the folder in which the files must be to match. The first match, starting bottom up, will be applied. Therefore, the first is the default pattern.").addButton((button) => {
      button.setTooltip("Add new pattern to match files in a directory.").setButtonText("+").setCta().onClick(() => {
        this.plugin.settings.patterns.push({
          headingVisual: "",
          headingSeparatorVisual: "",
          path: ""
        });
        this.plugin.saveSettings();
        this.display();
      });
    });
    this.plugin.settings.patterns.forEach(
      (pattern, index) => {
        const s = new import_obsidian.Setting(this.containerEl).addText((text) => text.setPlaceholder("Enter a heading override").setValue(pattern.headingVisual).onChange(async (value) => {
          pattern.headingVisual = value;
          await this.plugin.saveSettings();
          postProcessorUpdate(this.app);
        })).addText((text) => text.setPlaceholder("Enter a separator override").setValue(pattern.headingSeparatorVisual).onChange(async (value) => {
          pattern.headingSeparatorVisual = value;
          await this.plugin.saveSettings();
          postProcessorUpdate(this.app);
        })).addText((text) => text.setPlaceholder(index === 0 ? "(global)" : "Enter a path").setValue(pattern.path).setDisabled(index === 0).onChange(async (value) => {
          pattern.path = value;
          await this.plugin.saveSettings();
          postProcessorUpdate(this.app);
        }));
        if (index === 0) {
          s.addExtraButton((cb) => {
            cb.setIcon("lock").setTooltip("This pattern is the default and cannot be completed");
          });
        } else {
          if (index !== 0) {
            s.addExtraButton((cb) => {
              cb.setIcon("cross").setTooltip("Delete").onClick(() => {
                this.plugin.settings.patterns.splice(
                  index,
                  1
                );
                this.plugin.saveSettings();
                this.display();
              });
            });
          }
        }
      }
    );
  }
  createH2(text) {
    const { containerEl } = this;
    containerEl.createEl("h2", { text });
  }
};

// src/embeds.ts
var import_obsidian2 = require("obsidian");
async function replaceEmbed(embed, settings) {
  let embedHtml = embed;
  const link = parseLink(app, embedHtml, settings, true, "src");
  if (link == void 0) {
    return;
  }
  const isLinkRange = link.h2 !== void 0;
  if (!isLinkRange) {
    if (link.pattern !== settings.getDefaultPattern()) {
      updateHeading(embedHtml, link.altText);
    }
    return;
  }
  const { vault } = app;
  updateHeading(embedHtml, link.altText);
  const contentDiv = embedHtml.querySelector("div.markdown-embed-content");
  if (contentDiv == null || !(contentDiv instanceof HTMLElement))
    return;
  while (contentDiv.lastElementChild) {
    contentDiv.removeChild(contentDiv.lastElementChild);
  }
  contentDiv.childNodes.forEach((x) => {
    x.remove();
  });
  const fileContent = await vault.cachedRead(link.file);
  let lines = fileContent.split("\n");
  lines = lines.slice(link.h1Line, link.h2Line);
  import_obsidian2.MarkdownRenderer.renderMarkdown(lines.join("\n"), contentDiv, "", null);
  const linkDiv = embedHtml.querySelector("div.markdown-embed-link");
  if (linkDiv instanceof HTMLElement) {
    const newLink = linkDiv.cloneNode(true);
    linkDiv.replaceWith(newLink);
    newLink.onClickEvent((ev) => {
      const leaf = app.workspace.getMostRecentLeaf();
      const startLoc = Object.assign({ line: 0, col: 0, offset: 0 }, 0);
      const endLoc = Object.assign({ line: 0, col: 0, offset: 0 }, 0);
      const { line, col } = startLoc;
      const state = {
        eState: {
          startLoc,
          endLoc,
          line,
          cursor: {
            from: { line, ch: 0 },
            to: { line, ch: 0 }
          }
        }
      };
      leaf == null ? void 0 : leaf.openFile(link.file, state);
    });
  }
}
function updateHeading(elem, title, observer = void 0) {
  var _a;
  const titleElem = elem.querySelector(".embed-title.markdown-embed-title");
  const firstHeading = elem.querySelector("H1,H2,H3,H4,H5,H6");
  if (titleElem != null && firstHeading != null) {
    titleElem.setText(title);
    (_a = firstHeading.parentNode) == null ? void 0 : _a.removeChild(firstHeading);
    observer == null ? void 0 : observer.disconnect();
    return;
  }
  if (observer == void 0) {
    new MutationObserver((_, observer2) => {
      updateHeading(elem, title, observer2);
    }).observe(
      elem,
      { attributes: false, childList: true, subtree: true }
    );
  }
}

// src/markdownPostProcessor.ts
function linkRangePostProcessor(el, settings) {
  const links = el.querySelectorAll("a.internal-link");
  links.forEach((link) => {
    const htmlLink = link;
    const res = parseLink(app, htmlLink, settings);
    if (res !== null) {
      if (res.altText) {
        htmlLink.setText(res.altText);
      }
      htmlLink.setAttribute("href", res.note + "#" + res.h1);
      htmlLink.setAttribute("data-href", res.note + "#" + res.h1);
      htmlLink.setAttribute("range-href", res.note + "#" + res.h1 + settings.headingSeparator + res.h2);
    }
  });
  const embeds = el.querySelectorAll("span.internal-embed");
  embeds.forEach((embed) => {
    replaceEmbed(embed, settings);
  });
}

// src/livePreviewEmbedReplacer.ts
var import_view = require("@codemirror/view");
var import_obsidian3 = require("obsidian");
var import_state = require("@codemirror/state");
var LifePreviewEmbedReplacer = class {
  constructor(settings, app2) {
    this.decorations = import_view.Decoration.none;
    this.settings = settings;
    this.app = app2;
    this.embedCount = 0;
  }
  buildDecorations(view, embeds) {
    const buffer = new import_state.RangeSetBuilder();
    embeds.forEach((embed) => {
      replaceEmbed(embed, this.settings);
    });
    return buffer.finish();
  }
  update(update) {
    if (!update.state.field(import_obsidian3.editorLivePreviewField)) {
      this.decorations = import_view.Decoration.none;
      return;
    }
    const embeds = update.view.contentDOM.querySelectorAll("div.markdown-embed");
    if (embeds.length > 0 && embeds.length != this.embedCount || update.docChanged) {
      this.embedCount = embeds.length;
      this.decorations = this.buildDecorations(update.view, embeds);
    }
  }
};

// src/livePreviewDisplayView.ts
var import_view2 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var import_language = require("@codemirror/language");
var CharacterOverwriteWidget = class extends import_view2.WidgetType {
  constructor(char) {
    super();
    this.char = char;
  }
  toDOM() {
    let el = document.createElement("span");
    el.innerText = this.char;
    el.style.textDecoration = "underline";
    return el;
  }
};
function buildCMViewPlugin(app2, settings) {
  const viewPlugin = import_view2.ViewPlugin.fromClass(
    class {
      constructor(view) {
        this.decorations = this.buildDecorations(view, null);
        this.lastLocation = { from: 0, to: 0 };
        ;
      }
      update(update) {
        let currentLocation = {
          from: update.state.selection.ranges[0].from,
          to: update.state.selection.ranges[0].to
        };
        if (update.docChanged || update.viewportChanged) {
          this.decorations = this.buildDecorations(update.view, currentLocation);
        } else {
          let isRepeatUpdate = this.lastLocation.from == currentLocation.from && this.lastLocation.to === currentLocation.to;
          if (update.state.selection.ranges.length > 0 && !isRepeatUpdate) {
            this.decorations = this.buildDecorations(update.view, currentLocation);
          }
        }
        this.lastLocation = currentLocation;
      }
      buildDecorations(view, location) {
        let builder = new import_state2.RangeSetBuilder();
        const lastPassDecoratedRanges = this.decoratedRanges;
        this.decoratedRanges = [];
        const inLastPass = function(nodeStart, index) {
          if (index === void 0) {
            return false;
          }
          for (let i in lastPassDecoratedRanges) {
            const rng = lastPassDecoratedRanges[i];
            if (rng.from == nodeStart && index >= rng.from && index <= rng.to) {
              return true;
            }
          }
          return false;
        };
        for (let { from, to } of view.visibleRanges) {
          (0, import_language.syntaxTree)(view.state).iterate({
            from,
            to,
            enter: (node) => {
              const tokenProps = node.type.name.split("_");
              if (tokenProps) {
                const props = new Set(tokenProps);
                const isLink = props.has("hmd-internal-link");
                const isAlias = props.has("link-alias");
                const isPipe = props.has("link-alias-pipe");
                const isMDUrl = props.has("url");
                if (isLink && !isAlias && !isPipe || isMDUrl) {
                  let linkText = view.state.doc.sliceString(node.from, node.to);
                  const indexOfHeaderMarker = linkText.indexOf("#");
                  const indexOfHeaderMarkerInDoc = indexOfHeaderMarker + node.from;
                  if (indexOfHeaderMarkerInDoc >= node.from && indexOfHeaderMarkerInDoc <= node.to) {
                    if (!inLastPass(node.from - 2, location == null ? void 0 : location.from)) {
                      const fileName = linkText.substring(0, indexOfHeaderMarker);
                      const pattern = findPatternForFilename(fileName, settings);
                      if (pattern.headingVisual !== "") {
                        let overrideP2HWidget = import_view2.Decoration.widget({
                          widget: new CharacterOverwriteWidget(pattern.headingVisual)
                        });
                        builder.add(indexOfHeaderMarkerInDoc, indexOfHeaderMarkerInDoc + 1, overrideP2HWidget);
                      }
                      if (pattern.headingSeparatorVisual !== "") {
                        const indexOfRangeMarker = linkText.indexOf(settings.headingSeparator) + node.from;
                        if (indexOfRangeMarker >= node.from && indexOfRangeMarker <= node.to) {
                          let overrideH2HWidget = import_view2.Decoration.widget({
                            widget: new CharacterOverwriteWidget(pattern.headingSeparatorVisual)
                          });
                          builder.add(indexOfRangeMarker, indexOfRangeMarker + settings.headingSeparator.length, overrideH2HWidget);
                        }
                      }
                    }
                    this.decoratedRanges.push({
                      from: node.from - 2,
                      to: node.to + 2
                    });
                  }
                }
              }
            }
          });
        }
        const bufferedDecs = builder.finish();
        return bufferedDecs;
      }
    },
    {
      decorations: (v) => v.decorations
    }
  );
  return viewPlugin;
}

// main.ts
var import_state3 = require("@codemirror/state");
var LinkRange = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new LinkRangeSettingTab(this.app, this));
    const settings = this.settings;
    this.registerMarkdownPostProcessor((el) => {
      linkRangePostProcessor(el, settings);
    });
    this.app.workspace.onLayoutReady(() => {
      this.registerEditorExtension(import_view3.ViewPlugin.define((v) => {
        return new LifePreviewEmbedReplacer(this.settings, this.app);
      }));
      const ext = import_state3.Prec.lowest(buildCMViewPlugin(this.app, this.settings));
      this.registerEditorExtension(ext);
      const pagePreviewPlugin = this.app.internalPlugins.plugins["page-preview"];
      const uninstaller = around(pagePreviewPlugin.instance.constructor.prototype, {
        onHoverLink(old) {
          return function(options, ...args) {
            return old.call(this, options, ...args);
          };
        },
        onLinkHover(old) {
          return function(parent, targetEl, linkText, path2, state, ...args) {
            const res = parseLink(this.app, targetEl, settings, false, "range-href");
            if (res !== null) {
              old.call(this, parent, targetEl, res.note, path2, { scroll: res.h1Line }, ...args);
            } else {
              old.call(this, parent, targetEl, linkText, path2, state, ...args);
            }
          };
        }
      });
      this.register(uninstaller);
      pagePreviewPlugin.disable();
      pagePreviewPlugin.enable();
      this.register(function() {
        if (!pagePreviewPlugin.enabled)
          return;
        pagePreviewPlugin.disable();
        pagePreviewPlugin.enable();
      });
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvbW9ua2V5LWFyb3VuZC9tanMvaW5kZXguanMiLCAic3JjL3NldHRpbmdzLnRzIiwgInNyYy91dGlscy50cyIsICJzcmMvZW1iZWRzLnRzIiwgInNyYy9tYXJrZG93blBvc3RQcm9jZXNzb3IudHMiLCAic3JjL2xpdmVQcmV2aWV3RW1iZWRSZXBsYWNlci50cyIsICJzcmMvbGl2ZVByZXZpZXdEaXNwbGF5Vmlldy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgYXJvdW5kIH0gZnJvbSBcIm1vbmtleS1hcm91bmRcIjtcbmltcG9ydCB7IFZpZXdQbHVnaW4gfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgTGlua1JhbmdlU2V0dGluZ3MsIExpbmtSYW5nZVNldHRpbmdUYWIgfSBmcm9tICdzcmMvc2V0dGluZ3MnO1xuaW1wb3J0IHsgbGlua1JhbmdlUG9zdFByb2Nlc3NvciB9IGZyb20gJ3NyYy9tYXJrZG93blBvc3RQcm9jZXNzb3InO1xuaW1wb3J0IHsgcGFyc2VMaW5rIH0gZnJvbSAnc3JjL3V0aWxzJztcbmltcG9ydCB7IExpZmVQcmV2aWV3RW1iZWRSZXBsYWNlciB9IGZyb20gJ3NyYy9saXZlUHJldmlld0VtYmVkUmVwbGFjZXInO1xuaW1wb3J0IHsgYnVpbGRDTVZpZXdQbHVnaW4gfSBmcm9tICdzcmMvbGl2ZVByZXZpZXdEaXNwbGF5Vmlldyc7XG5pbXBvcnQgeyBQcmVjIH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtSYW5nZSBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBMaW5rUmFuZ2VTZXR0aW5ncztcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBMaW5rUmFuZ2VTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cblx0XHRjb25zdCBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG5cblx0XHR0aGlzLnJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yKChlbCkgPT4ge1xuXHRcdFx0bGlua1JhbmdlUG9zdFByb2Nlc3NvcihlbCwgc2V0dGluZ3MpXG5cdFx0fSk7XG5cblx0XHQvLyB3YWl0IGZvciBsYXlvdXQgdG8gYmUgcmVhZHlcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeSgoKSA9PiB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyRWRpdG9yRXh0ZW5zaW9uKFZpZXdQbHVnaW4uZGVmaW5lKCh2KSA9PiB7XG5cdFx0XHRcdHJldHVybiBuZXcgTGlmZVByZXZpZXdFbWJlZFJlcGxhY2VyKHRoaXMuc2V0dGluZ3MsIHRoaXMuYXBwKVxuXHRcdFx0fSkpO1xuXG5cdFx0XHRjb25zdCBleHQgPSBQcmVjLmxvd2VzdChidWlsZENNVmlld1BsdWdpbih0aGlzLmFwcCwgdGhpcy5zZXR0aW5ncykpO1xuXHRcdFx0dGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihleHQpO1xuXG5cdFx0XHRjb25zdCBwYWdlUHJldmlld1BsdWdpbiA9IHRoaXMuYXBwLmludGVybmFsUGx1Z2lucy5wbHVnaW5zW1wicGFnZS1wcmV2aWV3XCJdO1xuXHRcdFx0XG5cdFx0XHQvLyBpbnRlcmNlcHQgcGFnZS1wcmV2aWV3IHBsdWdpblxuXHRcdFx0Y29uc3QgdW5pbnN0YWxsZXIgPSBhcm91bmQocGFnZVByZXZpZXdQbHVnaW4uaW5zdGFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlLCB7XG5cdFx0XHRcdG9uSG92ZXJMaW5rKG9sZDogRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnM6IHsgZXZlbnQ6IE1vdXNlRXZlbnQgfSwgLi4uYXJnczogdW5rbm93bltdKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2xkLmNhbGwodGhpcywgb3B0aW9ucywgLi4uYXJncyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25MaW5rSG92ZXIob2xkOiBGdW5jdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoXG5cdFx0XHRcdFx0XHRwYXJlbnQ6IGFueSxcblx0XHRcdFx0XHRcdHRhcmdldEVsOiBIVE1MRWxlbWVudCxcblx0XHRcdFx0XHRcdGxpbmtUZXh0OiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRwYXRoOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRzdGF0ZTogYW55LFxuXHRcdFx0XHRcdFx0Li4uYXJnczogdW5rbm93bltdXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyBwYXJzZSBsaW5rIHVzaW5nIHRoZSBhZGRlZCByYW5nZS1ocmVmIGZpZWxkXG5cdFx0XHRcdFx0XHRjb25zdCByZXMgPSBwYXJzZUxpbmsodGhpcy5hcHAsIHRhcmdldEVsLCBzZXR0aW5ncywgZmFsc2UsIFwicmFuZ2UtaHJlZlwiKVxuXHRcdFx0XHRcdFx0aWYgKHJlcyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRvbGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRhcmdldEVsLCByZXMubm90ZSwgcGF0aCwge3Njcm9sbDpyZXMuaDFMaW5lfSwgLi4uYXJncylcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG9sZC5jYWxsKHRoaXMsIHBhcmVudCwgdGFyZ2V0RWwsIGxpbmtUZXh0LCBwYXRoLCBzdGF0ZSwgLi4uYXJncyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5yZWdpc3Rlcih1bmluc3RhbGxlcik7XG5cdFx0XG5cdFx0XHQvLyBUaGlzIHdpbGwgcmVjeWNsZSB0aGUgZXZlbnQgaGFuZGxlcnMgc28gdGhhdCB0aGV5IHBpY2sgdXAgdGhlIHBhdGNoZWQgb25MaW5rSG92ZXIgbWV0aG9kXG5cdFx0XHRwYWdlUHJldmlld1BsdWdpbi5kaXNhYmxlKCk7XG5cdFx0XHRwYWdlUHJldmlld1BsdWdpbi5lbmFibGUoKTtcblx0XHRcblx0XHRcdHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoIXBhZ2VQcmV2aWV3UGx1Z2luLmVuYWJsZWQpIHJldHVybjtcblx0XHRcdFx0cGFnZVByZXZpZXdQbHVnaW4uZGlzYWJsZSgpO1xuXHRcdFx0XHRwYWdlUHJldmlld1BsdWdpbi5lbmFibGUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0b251bmxvYWQoKSB7XG5cblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGFyb3VuZChvYmosIGZhY3Rvcmllcykge1xuICAgIGNvbnN0IHJlbW92ZXJzID0gT2JqZWN0LmtleXMoZmFjdG9yaWVzKS5tYXAoa2V5ID0+IGFyb3VuZDEob2JqLCBrZXksIGZhY3Rvcmllc1trZXldKSk7XG4gICAgcmV0dXJuIHJlbW92ZXJzLmxlbmd0aCA9PT0gMSA/IHJlbW92ZXJzWzBdIDogZnVuY3Rpb24gKCkgeyByZW1vdmVycy5mb3JFYWNoKHIgPT4gcigpKTsgfTtcbn1cbmZ1bmN0aW9uIGFyb3VuZDEob2JqLCBtZXRob2QsIGNyZWF0ZVdyYXBwZXIpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IG9ialttZXRob2RdLCBoYWRPd24gPSBvYmouaGFzT3duUHJvcGVydHkobWV0aG9kKTtcbiAgICBsZXQgY3VycmVudCA9IGNyZWF0ZVdyYXBwZXIob3JpZ2luYWwpO1xuICAgIC8vIExldCBvdXIgd3JhcHBlciBpbmhlcml0IHN0YXRpYyBwcm9wcyBmcm9tIHRoZSB3cmFwcGluZyBtZXRob2QsXG4gICAgLy8gYW5kIHRoZSB3cmFwcGluZyBtZXRob2QsIHByb3BzIGZyb20gdGhlIG9yaWdpbmFsIG1ldGhvZFxuICAgIGlmIChvcmlnaW5hbClcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGN1cnJlbnQsIG9yaWdpbmFsKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yod3JhcHBlciwgY3VycmVudCk7XG4gICAgb2JqW21ldGhvZF0gPSB3cmFwcGVyO1xuICAgIC8vIFJldHVybiBhIGNhbGxiYWNrIHRvIGFsbG93IHNhZmUgcmVtb3ZhbFxuICAgIHJldHVybiByZW1vdmU7XG4gICAgZnVuY3Rpb24gd3JhcHBlciguLi5hcmdzKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYmVlbiBkZWFjdGl2YXRlZCBhbmQgYXJlIG5vIGxvbmdlciB3cmFwcGVkLCByZW1vdmUgb3Vyc2VsdmVzXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBvcmlnaW5hbCAmJiBvYmpbbWV0aG9kXSA9PT0gd3JhcHBlcilcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gY3VycmVudC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAvLyBJZiBubyBvdGhlciBwYXRjaGVzLCBqdXN0IGRvIGEgZGlyZWN0IHJlbW92YWxcbiAgICAgICAgaWYgKG9ialttZXRob2RdID09PSB3cmFwcGVyKSB7XG4gICAgICAgICAgICBpZiAoaGFkT3duKVxuICAgICAgICAgICAgICAgIG9ialttZXRob2RdID0gb3JpZ2luYWw7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBvcmlnaW5hbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gRWxzZSBwYXNzIGZ1dHVyZSBjYWxscyB0aHJvdWdoLCBhbmQgcmVtb3ZlIHdyYXBwZXIgZnJvbSB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgICAgIGN1cnJlbnQgPSBvcmlnaW5hbDtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHdyYXBwZXIsIG9yaWdpbmFsIHx8IEZ1bmN0aW9uKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVkdXBlKGtleSwgb2xkRm4sIG5ld0ZuKSB7XG4gICAgY2hlY2tba2V5XSA9IGtleTtcbiAgICByZXR1cm4gY2hlY2s7XG4gICAgZnVuY3Rpb24gY2hlY2soLi4uYXJncykge1xuICAgICAgICByZXR1cm4gKG9sZEZuW2tleV0gPT09IGtleSA/IG9sZEZuIDogbmV3Rm4pLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhZnRlcihwcm9taXNlLCBjYikge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2IsIGNiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoYXN5bmNGdW5jdGlvbikge1xuICAgIGxldCBsYXN0UnVuID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgZnVuY3Rpb24gd3JhcHBlciguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBsYXN0UnVuID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBhZnRlcihsYXN0UnVuLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXN5bmNGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKS50aGVuKHJlcywgcmVqKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JhcHBlci5hZnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3RSdW4gPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHsgYWZ0ZXIobGFzdFJ1biwgcmVzKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbn1cbiIsICJpbXBvcnQgTGlua1JhbmdlIGZyb20gXCJtYWluXCI7XG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcG9zdFByb2Nlc3NvclVwZGF0ZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF0dGVybiB7XG5cdGhlYWRpbmdWaXN1YWw6IHN0cmluZztcblx0aGVhZGluZ1NlcGFyYXRvclZpc3VhbDogc3RyaW5nO1xuXHRwYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1JhbmdlU2V0dGluZ3Mge1xuXHRoZWFkaW5nU2VwYXJhdG9yOiBzdHJpbmc7XG5cdGVuZEluY2x1c2l2ZTogYm9vbGVhbjtcblx0YWx0Rm9ybWF0OiBzdHJpbmc7IC8vIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdHNldHRpbmdzVmVyc2lvbjogc3RyaW5nO1xuXHRwYXR0ZXJuczogW1BhdHRlcm5dXG5cdGdldERlZmF1bHRQYXR0ZXJuKCkgOiBQYXR0ZXJuXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBMaW5rUmFuZ2VTZXR0aW5ncyA9IHtcblx0aGVhZGluZ1NlcGFyYXRvcjogJy4uJyxcblx0ZW5kSW5jbHVzaXZlOiB0cnVlLFxuXHRhbHRGb3JtYXQ6ICcnLFxuXHRzZXR0aW5nc1ZlcnNpb246ICd2MicsXG5cdHBhdHRlcm5zOiBbeyBoZWFkaW5nVmlzdWFsOiAnLi4nLCBoZWFkaW5nU2VwYXJhdG9yVmlzdWFsOiAnLScsIHBhdGg6ICcvJyB9XSxcblxuXHRnZXREZWZhdWx0UGF0dGVybigpIHtcblx0XHRjb25zdCBmaXJzdCA9IHRoaXMucGF0dGVybnNbMF07XG5cdFx0aWYgKCFmaXJzdCkge1xuXHRcdFx0cmV0dXJuIHsgaGVhZGluZ1Zpc3VhbDogJzonLCBoZWFkaW5nU2VwYXJhdG9yVmlzdWFsOiAnLScsIHBhdGg6ICcvJyB9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxufVxuXG5leHBvcnQgY2xhc3MgTGlua1JhbmdlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IExpbmtSYW5nZTtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBMaW5rUmFuZ2UpIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdFx0dGhpcy5taWdyYXRlT2xkU2V0dGluZ3MoKTtcblx0fVxuXG5cdG1pZ3JhdGVPbGRTZXR0aW5ncygpIHtcblx0XHRjb25zdCBzdGdzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG5cblx0XHRjb25zdCBoYXNWMVNldHRpbmdzID0gc3Rncy5hbHRGb3JtYXQgIT0gdW5kZWZpbmVkICYmIHN0Z3MuYWx0Rm9ybWF0Lmxlbmd0aCA+IDA7XG5cdFx0aWYgKGhhc1YxU2V0dGluZ3MpIHtcdFxuXG5cdFx0XHQvLyBkZWZhdWx0IGFsdEZvcm1hdCBzdHJpbmc6IGAkbm90ZTokaDEtJGgyYFxuXHRcdFx0Y29uc3QgYWx0Rm9ybWF0ID0gc3Rncy5hbHRGb3JtYXQ7XG5cdFx0XHRjb25zdCBpbmRleE9mTm90ZSA9IGFsdEZvcm1hdC5pbmRleE9mKCckbm90ZScpO1xuXHRcdFx0Y29uc3QgaW5kZXhPZkgxID0gYWx0Rm9ybWF0LmluZGV4T2YoJyRoMScpO1xuXHRcdFx0Y29uc3QgaW5kZXhPZkgyID0gYWx0Rm9ybWF0LmluZGV4T2YoJyRoMicpO1xuXG5cdFx0XHRjb25zdCBmb3JtYXRJc1ZhbGlkID0gaW5kZXhPZk5vdGUgPT09IDAgJiYgaW5kZXhPZkgxICE9PSAtMSAmJiBpbmRleE9mSDIgIT09IC0yO1xuXHRcdFx0XG5cdFx0XHRpZiAoZm9ybWF0SXNWYWxpZCkge1xuXHRcdFx0XHRjb25zdCBmaXJzdFZhbHVlID0gYWx0Rm9ybWF0LnN1YnN0cmluZygnJG5vdGUnLmxlbmd0aCwgaW5kZXhPZkgxKTtcblx0XHRcdFx0Y29uc3Qgc2Vjb25kVmFsdWUgPSBhbHRGb3JtYXQuc3Vic3RyaW5nKGluZGV4T2ZIMSArICckaDEnLmxlbmd0aCwgaW5kZXhPZkgyKTtcblxuXHRcdFx0XHRzdGdzLnBhdHRlcm5zID0gW3sgaGVhZGluZ1Zpc3VhbDogZmlyc3RWYWx1ZSwgaGVhZGluZ1NlcGFyYXRvclZpc3VhbDogc2Vjb25kVmFsdWUsIHBhdGg6ICcnIH1dXG5cdFx0XHR9XG5cblx0XHRcdHN0Z3MuYWx0Rm9ybWF0ID0gJyc7XG5cdFx0XHR0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHR9XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdHRoaXMuY3JlYXRlSDIoJ1NldHRpbmdzIGZvciBsaW5rLXJhbmdlIHBsdWdpbicpXG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdIZWFkaW5nIFNlcGFyYXRvcicpXG5cdFx0XHQuc2V0RGVzYygnRGVmaW5lcyB0aGUgc2VwYXJhdG9yIHRvIGJlIHVzZWQgdG8gZGVmaW5lIGEgbGluayBoZWFkaW5nIHJhbmdlLiBEZWZhdWx0cyB0byBcIi4uXCIgKGUuZy4gW1tOb3RlIE5hbWUjaDEuLmgyXV0pJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIGEgc2VwYXJhdG9yIHN0cmluZyAoZGVmYXVsdHMgdG8gLi4pJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmhlYWRpbmdTZXBhcmF0b3IpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5oZWFkaW5nU2VwYXJhdG9yID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0cG9zdFByb2Nlc3NvclVwZGF0ZSh0aGlzLmFwcClcblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnRW5kIEluY2x1c2l2ZScpXG5cdFx0XHQuc2V0RGVzYygnV2hldGhlciBvciBub3QgdGhlIGVuZCBoZWFkaW5nIHNob3VsZCBiZSBpbmNsdXNpdmUgb3IgZXhjbHVzaXZlJylcblx0XHRcdC5hZGRUb2dnbGUoYm9vbCA9PiBib29sXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmRJbmNsdXNpdmUpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmRJbmNsdXNpdmUgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRwb3N0UHJvY2Vzc29yVXBkYXRlKHRoaXMuYXBwKVxuXHRcdFx0XHR9KSk7XG5cdFxuXHRcdG5ldyBTZXR0aW5nKHRoaXMuY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIkFkZCBhIE5ldyBWaXN1YWwgUGF0dGVyblwiKVxuXHRcdFx0LnNldERlc2MoXCJBZGQgbmV3IHBhdHRlcm4gdG8gbWF0Y2ggZmlsZXMgaW4gYSBkaXJlY3RvcnkuIFRoZSBmaXJzdCB2YWx1ZSB3aWxsIGNoYW5nZSB0aGUgdmlzdWFsIGZvciB0aGUgaGVhZGluZyBpbiBhIGxpbmsuIFRoZSBzZWNvbmQgdmFsdWUgd2lsbCBjaGFuZ2UgdGhlIHZpc3VhbCBmb3Igc2VwYXJhdG9yLiBUaGUgdGhpcmQgc3BlY2lmaWVzIHRoZSBmb2xkZXIgaW4gd2hpY2ggdGhlIGZpbGVzIG11c3QgYmUgdG8gbWF0Y2guIFRoZSBmaXJzdCBtYXRjaCwgc3RhcnRpbmcgYm90dG9tIHVwLCB3aWxsIGJlIGFwcGxpZWQuIFRoZXJlZm9yZSwgdGhlIGZpcnN0IGlzIHRoZSBkZWZhdWx0IHBhdHRlcm4uXCIpXG5cdFx0XHQuYWRkQnV0dG9uKChidXR0b246IEJ1dHRvbkNvbXBvbmVudCkgPT4ge1xuXHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIkFkZCBuZXcgcGF0dGVybiB0byBtYXRjaCBmaWxlcyBpbiBhIGRpcmVjdG9yeS5cIilcblx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIitcIilcblx0XHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXR0ZXJucy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aGVhZGluZ1Zpc3VhbDogJycsXG5cdFx0XHRcdFx0XHRcdGhlYWRpbmdTZXBhcmF0b3JWaXN1YWw6ICcnLFxuXHRcdFx0XHRcdFx0XHRwYXRoOiAnJ1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XG5cdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYXR0ZXJucy5mb3JFYWNoKFxuXHRcdFx0XHQocGF0dGVybiwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBzID0gbmV3IFNldHRpbmcodGhpcy5jb250YWluZXJFbClcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgYSBoZWFkaW5nIG92ZXJyaWRlJylcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwYXR0ZXJuLmhlYWRpbmdWaXN1YWwpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm4uaGVhZGluZ1Zpc3VhbCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0cG9zdFByb2Nlc3NvclVwZGF0ZSh0aGlzLmFwcClcblx0XHRcdFx0XHRcdH0pKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciBhIHNlcGFyYXRvciBvdmVycmlkZScpXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUocGF0dGVybi5oZWFkaW5nU2VwYXJhdG9yVmlzdWFsKVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuLmhlYWRpbmdTZXBhcmF0b3JWaXN1YWwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdHBvc3RQcm9jZXNzb3JVcGRhdGUodGhpcy5hcHApXG5cdFx0XHRcdFx0XHR9KSlcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihpbmRleCA9PT0gMCA/ICcoZ2xvYmFsKScgOiAnRW50ZXIgYSBwYXRoJylcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwYXR0ZXJuLnBhdGgpXG5cdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQoaW5kZXggPT09IDApXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm4ucGF0aCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0cG9zdFByb2Nlc3NvclVwZGF0ZSh0aGlzLmFwcClcblx0XHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cy5hZGRFeHRyYUJ1dHRvbigoY2IpID0+IHtcblx0XHRcdFx0XHRcdFx0Y2Iuc2V0SWNvbihcImxvY2tcIilcblx0XHRcdFx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIlRoaXMgcGF0dGVybiBpcyB0aGUgZGVmYXVsdCBhbmQgY2Fubm90IGJlIGNvbXBsZXRlZFwiKTtcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5kZXggIT09IDApIHtcblx0XHRcdFx0XHRcdFx0cy5hZGRFeHRyYUJ1dHRvbigoY2IpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjYi5zZXRJY29uKFwiY3Jvc3NcIilcblx0XHRcdFx0XHRcdFx0XHRcdC5zZXRUb29sdGlwKFwiRGVsZXRlXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnBhdHRlcm5zLnNwbGljZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0fVxuXG5cdGNyZWF0ZUgyKHRleHQ6IHN0cmluZykge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogdGV4dCB9KTtcblx0fVxuXG5cdFxufVxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IExpbmtSYW5nZVNldHRpbmdzLCBQYXR0ZXJuIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkTGluayB7XG5cdC8vIE5BTUUgaW4gW1tOQU1FI0gxLi5IMnxBTFRdXVxuXHRub3RlOiBzdHJpbmc7XG5cdC8vIEgxIChyZXF1aXJlZCEpXG5cdGgxOiBzdHJpbmc7XG5cdC8vIChvcHRpb25hbCkgSDJcblx0aDI/OiBzdHJpbmc7XG5cdC8vIChvcHRpb25hbCkgQUxUXG5cdGFsdFRleHQ6IHN0cmluZztcblx0Ly8gUGF0dGVybiB0byBhcHBseSBmcm9tIHNldHRpbmdzXG5cdHBhdHRlcm46IFBhdHRlcm47XG5cdC8vIEZpbGUgcmVmZXJyZWQgdG8gYnkgbm90ZVxuXHRmaWxlOiBURmlsZTtcblx0Ly8gaDEgcm93IGluIGZpbGVcblx0aDFMaW5lOiBudW1iZXI7XG5cdC8vIChvcHRpb25hbCkgaDIgcm93IGluIGZpbGVcblx0aDJMaW5lPzogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhyZWZMaW5rKGhyZWY6IHN0cmluZywgc2V0dGluZ3M6IExpbmtSYW5nZVNldHRpbmdzKTogUGFyc2VkTGluayB8IG51bGwge1xuXHRjb25zdCBsaW5rUmVnZXggPSAvKFteI3xdKikjPyhbXiN8XSopP1xcfD8oLiopPy87XG5cblx0Y29uc3QgbWF0Y2hlcyA9IGxpbmtSZWdleC5leGVjKGhyZWYpO1xuXG5cdGlmIChtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlcy5sZW5ndGggPCAzIHx8IG1hdGNoZXNbMl0gPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBub3RlID0gbWF0Y2hlc1sxXTtcblxuXHQvLyBMb2NhdGUgdGhlIHJlZmVyZW5jZWQgZmlsZSwgaW5jbHVkaW5nIHBhcnRpYWwgcGF0aHNcblx0Y29uc3QgcGFydGlhbFBhdGggPSBub3RlICsgXCIubWRcIlxuXHRjb25zdCBiYXNlUGFydCA9IHBhdGguYmFzZW5hbWUobm90ZSlcblx0XHRjb25zdCBmaWxlOiBURmlsZSB8IHVuZGVmaW5lZCA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKFxuXHRcdHggPT4geC5iYXNlbmFtZSA9PSBiYXNlUGFydCAmJiB4LnBhdGguZW5kc1dpdGgocGFydGlhbFBhdGgpXG5cdCkuZmlyc3QoKVxuXG5cdGlmICghZmlsZSkgcmV0dXJuIG51bGw7XG5cdFxuXHRjb25zdCBwYXR0ZXJuID0gZmluZFBhdHRlcm5Gb3JGaWxlKGZpbGUsIHNldHRpbmdzKTtcblxuXHRjb25zdCBzcGxpdCA9IG1hdGNoZXNbMl0uc3BsaXQoc2V0dGluZ3MuaGVhZGluZ1NlcGFyYXRvcik7XG5cdGNvbnN0IGgxID0gc3BsaXRbMF07XG5cdGNvbnN0IGgyID0gc3BsaXRbMV07XG5cblx0Ly8gQ2FwdHVyZSBvciBjcmVhdGUgYWx0LXRleHRcblx0bGV0IGFsdFRleHQgPSBcIlwiO1xuXHRpZiAobWF0Y2hlcy5sZW5ndGggPiAzICYmIG1hdGNoZXNbM10gIT0gdW5kZWZpbmVkKSB7XG5cdFx0YWx0VGV4dCA9IG1hdGNoZXNbM11cblx0fSBlbHNlIHtcblx0XHRjb25zdCBoZWFkaW5nVmlzdWFsID0gcGF0dGVybi5oZWFkaW5nVmlzdWFsID09PSAnJyA/ICcjJyA6IHBhdHRlcm4uaGVhZGluZ1Zpc3VhbDtcblx0XHRjb25zdCBoZWFkaW5nU2VwYXJhdG9yVmlzdWFsID0gcGF0dGVybi5oZWFkaW5nU2VwYXJhdG9yVmlzdWFsID09PSAnJyA/IHNldHRpbmdzLmhlYWRpbmdTZXBhcmF0b3IgOiBwYXR0ZXJuLmhlYWRpbmdTZXBhcmF0b3JWaXN1YWw7XG5cdFx0aWYgKGgyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFsdFRleHQgPSBgJHtiYXNlUGFydH0ke2hlYWRpbmdWaXN1YWx9JHtoMX0ke2hlYWRpbmdTZXBhcmF0b3JWaXN1YWx9JHtoMn1gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbHRUZXh0ID0gYCR7YmFzZVBhcnR9JHtoZWFkaW5nVmlzdWFsfSR7aDF9YDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBcblx0XHRub3RlOiBub3RlLCBcblx0XHRoMTogaDEsIFxuXHRcdGgyOiBoMiwgXG5cdFx0YWx0VGV4dDogYWx0VGV4dCwgXG5cdFx0cGF0dGVybjogcGF0dGVybixcblx0XHRmaWxlOiBmaWxlLFxuXHRcdC8vIFdpbGwgZmluZCB0aGVzZSBsYXRlciBcblx0XHRoMUxpbmU6IDAsICBcblx0XHRoMkxpbmU6IHVuZGVmaW5lZFxuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMaW5rKGFwcDogQXBwLCBsaW5rSFRNTDogSFRNTEVsZW1lbnQsIHNldHRpbmdzOiBMaW5rUmFuZ2VTZXR0aW5ncywgaXNFbWJlZD1mYWxzZSwgaHJlZkZpZWxkID0gXCJkYXRhLWhyZWZcIik6IFBhcnNlZExpbmsgfCBudWxsIHtcblx0Y29uc3QgaHJlZiA9IGxpbmtIVE1MLmdldEF0dHJpYnV0ZShocmVmRmllbGQpO1xuXG5cdGlmIChocmVmID09IG51bGwpIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IHJlcyA9IHBhcnNlSHJlZkxpbmsoaHJlZiwgc2V0dGluZ3MpXG5cdGlmICghcmVzIHx8IGFwcC5tZXRhZGF0YUNhY2hlID09IG51bGwpIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IGFsdCA9IGxpbmtIVE1MLmdldEF0dHJpYnV0ZShcImFsdFwiKTtcblxuXHQvLyBub24tc3RhbmRhcmQgYWx0IHRleHQsIG11c3QgYmUgdXNlciBwcm92aWRlZCB2aWEgXCJ8XCJcblx0aWYgKGFsdCAhPSBudWxsICYmICFhbHQuY29udGFpbnMocmVzLm5vdGUpKSB7XG5cdFx0cmVzLmFsdFRleHQgPSBhbHQ7XG5cdH1cblxuXHRpZiAoIWlzRW1iZWQgJiYgIWxpbmtIVE1MLmlubmVyVGV4dC5jb250YWlucyhyZXMubm90ZSkpIHtcblx0XHRyZXMuYWx0VGV4dCA9IGxpbmtIVE1MLmlubmVyVGV4dDtcblx0fVxuXG5cdGNvbnN0IG1ldGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUocmVzLmZpbGUpO1xuXG5cdGlmIChtZXRhID09IHVuZGVmaW5lZCB8fCBtZXRhLmhlYWRpbmdzID09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gTG9vayBmb3IgZmlyc3QgZXhhY3QgbWF0Y2ggZm9yIGgxIHRleHRcblx0Y29uc3QgaDFMaW5lID0gbWV0YT8uaGVhZGluZ3M/LmZpbHRlcihcblx0XHRoID0+IGguaGVhZGluZyA9PSByZXMuaDFcblx0KS5maXJzdCgpPy5wb3NpdGlvbi5zdGFydC5saW5lO1xuXHRpZiAoaDFMaW5lID09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cdHJlcy5oMUxpbmUgPSBoMUxpbmU7XG5cblx0Ly8gTG9vayBmb3IgaDJMaW5lIGlmIHdlIGNhblxuXHRpZiAocmVzLmgyICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoc2V0dGluZ3MuZW5kSW5jbHVzaXZlKSB7XG5cdFx0XHRsZXQgaDJMaW5lSW5kZXggPSBtZXRhPy5oZWFkaW5ncz8uZmluZEluZGV4KGggPT4gaC5oZWFkaW5nID09IHJlcy5oMilcblxuXHRcdFx0aWYgKG1ldGE/LmhlYWRpbmdzPy5sZW5ndGggPiBoMkxpbmVJbmRleCkge1xuXHRcdFx0XHRoMkxpbmVJbmRleCArPSAxXG5cdFx0XHR9XG5cblx0XHRcdHJlcy5oMkxpbmUgPSBtZXRhPy5oZWFkaW5ncz8uYXQoaDJMaW5lSW5kZXgpPy5wb3NpdGlvbi5lbmQubGluZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzLmgyTGluZSA9IG1ldGE/LmhlYWRpbmdzPy5maWx0ZXIoXG5cdFx0XHRcdGggPT4gaC5oZWFkaW5nID09IHJlcy5oMlxuXHRcdFx0KS5maXJzdCgpPy5wb3NpdGlvbi5lbmQubGluZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdFByb2Nlc3NvclVwZGF0ZShhcHA6IEFwcCkge1xuXHRmb3IgKGNvbnN0IGxlYWYgb2YgYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ21hcmtkb3duJykpIHtcblx0XHQvLyBBY3R1YWxseSBvZiB0eXBlIE1hcmtkb3duVmlldywgYnV0IGNhc3RpbmcgdG8gYW55IGJlY2F1c2UgdGhlIFRTIHR5cGVzIGRvbid0IGhhdmUgcHJldmlld01vZGUucmVuZGVyZXIgb3IgZWRpdG9yLmNtLi4uIFxuXHRcdGNvbnN0IHZpZXcgPSBsZWFmLnZpZXcgYXMgYW55O1xuXG5cdFx0dmlldy5wcmV2aWV3TW9kZS5yZW5kZXJlci5jbGVhcigpO1xuXHRcdHZpZXcucHJldmlld01vZGUucmVuZGVyZXIuc2V0KHZpZXcuZWRpdG9yLmNtLnN0YXRlLmRvYy50b1N0cmluZygpKTtcblx0fVxuXG5cdGFwcC53b3Jrc3BhY2UudXBkYXRlT3B0aW9ucygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhdHRlcm5Gb3JGaWxlbmFtZShmaWxlTmFtZTogc3RyaW5nLCBzZXR0aW5nczogTGlua1JhbmdlU2V0dGluZ3MpIDogUGF0dGVybiB7XG5cdGNvbnN0IGZpbGUgPSBhcHAudmF1bHQuZ2V0RmlsZXMoKS5maW5kKChmaWxlKSA9PiBmaWxlLmJhc2VuYW1lID09PSBmaWxlTmFtZSk7XG5cdHJldHVybiBmaW5kUGF0dGVybkZvckZpbGUoZmlsZSwgc2V0dGluZ3MpO1xufVxuXG5mdW5jdGlvbiBmaW5kUGF0dGVybkZvckZpbGUoZmlsZTogVEZpbGUgfCB1bmRlZmluZWQsIHNldHRpbmdzOiBMaW5rUmFuZ2VTZXR0aW5ncykgOiBQYXR0ZXJuIHtcblx0aWYgKGZpbGUpIHtcblx0XHRsZXQgcGF0dGVybiA9IFsuLi5zZXR0aW5ncy5wYXR0ZXJuc10ucmV2ZXJzZSgpLmZpbmQoKHBhdHRlcm46IFBhdHRlcm4pID0+XG5cdFx0XHRmaWxlLnBhdGguc3RhcnRzV2l0aChwYXR0ZXJuLnBhdGgpXG5cdFx0KVxuXHRcdGlmIChwYXR0ZXJuKSByZXR1cm4gcGF0dGVybjtcblx0fVxuXG5cdHJldHVybiBzZXR0aW5ncy5nZXREZWZhdWx0UGF0dGVybigpO1xufVxuIiwgImltcG9ydCB7IEFwcCwgTWFya2Rvd25SZW5kZXJlciwgc2V0SWNvbiwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IExpbmtSYW5nZVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IHBhcnNlTGluayB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXBsYWNlRW1iZWQoZW1iZWQ6IE5vZGUsIHNldHRpbmdzOiBMaW5rUmFuZ2VTZXR0aW5ncykge1xuXHRsZXQgZW1iZWRIdG1sID0gZW1iZWQgYXMgSFRNTEVsZW1lbnRcblxuXHRjb25zdCBsaW5rID0gcGFyc2VMaW5rKGFwcCwgZW1iZWRIdG1sLCBzZXR0aW5ncywgdHJ1ZSwgXCJzcmNcIik7XG5cdGlmIChsaW5rID09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBpc0xpbmtSYW5nZSA9IGxpbmsuaDIgIT09IHVuZGVmaW5lZDtcblxuXHRpZiAoIWlzTGlua1JhbmdlKSB7XG5cdFx0aWYgKGxpbmsucGF0dGVybiAhPT0gc2V0dGluZ3MuZ2V0RGVmYXVsdFBhdHRlcm4oKSkge1xuXHRcdFx0dXBkYXRlSGVhZGluZyhlbWJlZEh0bWwsIGxpbmsuYWx0VGV4dCk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHsgdmF1bHQgfSA9IGFwcDtcblxuXHR1cGRhdGVIZWFkaW5nKGVtYmVkSHRtbCwgbGluay5hbHRUZXh0KTtcblxuXHRjb25zdCBjb250ZW50RGl2ID0gZW1iZWRIdG1sLnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5tYXJrZG93bi1lbWJlZC1jb250ZW50Jylcblx0aWYgKGNvbnRlbnREaXYgPT0gbnVsbCB8fCAhKGNvbnRlbnREaXYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcblx0d2hpbGUgKGNvbnRlbnREaXYubGFzdEVsZW1lbnRDaGlsZCkge1xuXHRcdGNvbnRlbnREaXYucmVtb3ZlQ2hpbGQoY29udGVudERpdi5sYXN0RWxlbWVudENoaWxkKVxuXHR9XG5cdGNvbnRlbnREaXYuY2hpbGROb2Rlcy5mb3JFYWNoKHggPT4geyB4LnJlbW92ZSgpIH0pO1xuXG5cdGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChsaW5rLmZpbGUpO1xuXHRsZXQgbGluZXMgPSBmaWxlQ29udGVudC5zcGxpdChcIlxcblwiKTtcblx0bGluZXMgPSBsaW5lcy5zbGljZShsaW5rLmgxTGluZSwgbGluay5oMkxpbmUpO1xuXHRNYXJrZG93blJlbmRlcmVyLnJlbmRlck1hcmtkb3duKGxpbmVzLmpvaW4oXCJcXG5cIiksIGNvbnRlbnREaXYsIFwiXCIsIG51bGwhKVxuXG5cdGNvbnN0IGxpbmtEaXYgPSBlbWJlZEh0bWwucXVlcnlTZWxlY3RvcignZGl2Lm1hcmtkb3duLWVtYmVkLWxpbmsnKVxuXHRpZiAobGlua0RpdiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3QgbmV3TGluayA9IGxpbmtEaXYuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHRcdGxpbmtEaXYucmVwbGFjZVdpdGgobmV3TGluaylcblx0XHRuZXdMaW5rLm9uQ2xpY2tFdmVudCgoZXY6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdGNvbnN0IGxlYWYgPSBhcHAud29ya3NwYWNlLmdldE1vc3RSZWNlbnRMZWFmKCk7XG5cblx0XHRcdGNvbnN0IHN0YXJ0TG9jID0gT2JqZWN0LmFzc2lnbih7IGxpbmU6IDAsIGNvbDogMCwgb2Zmc2V0OiAwIH0sIDApO1xuXHRcdFx0Y29uc3QgZW5kTG9jID0gT2JqZWN0LmFzc2lnbih7IGxpbmU6IDAsIGNvbDogMCwgb2Zmc2V0OiAwIH0sIDApO1xuXHRcdFx0Y29uc3QgeyBsaW5lLCBjb2wgfSA9IHN0YXJ0TG9jO1xuXHRcdFx0Y29uc3Qgc3RhdGUgPSB7XG5cdFx0XHRcdGVTdGF0ZToge1xuXHRcdFx0XHRcdHN0YXJ0TG9jLFxuXHRcdFx0XHRcdGVuZExvYyxcblx0XHRcdFx0XHRsaW5lLFxuXHRcdFx0XHRcdGN1cnNvcjoge1xuXHRcdFx0XHRcdFx0ZnJvbTogeyBsaW5lLCBjaDogMCB9LFxuXHRcdFx0XHRcdFx0dG86IHsgbGluZSwgY2g6IDAgfSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRsZWFmPy5vcGVuRmlsZShsaW5rLmZpbGUsIHN0YXRlKTtcblx0XHR9KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhlYWRpbmcoXG5cdGVsZW06IEVsZW1lbnQsXG5cdHRpdGxlOiBzdHJpbmcsXG5cdG9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4pIHtcblx0Y29uc3QgdGl0bGVFbGVtID0gZWxlbS5xdWVyeVNlbGVjdG9yKCcuZW1iZWQtdGl0bGUubWFya2Rvd24tZW1iZWQtdGl0bGUnKTtcblx0Y29uc3QgZmlyc3RIZWFkaW5nID0gZWxlbS5xdWVyeVNlbGVjdG9yKCdIMSxIMixIMyxINCxINSxINicpO1xuXHRpZiAodGl0bGVFbGVtICE9IG51bGwgJiYgZmlyc3RIZWFkaW5nICE9IG51bGwpIHtcblx0XHR0aXRsZUVsZW0uc2V0VGV4dCh0aXRsZSk7XG5cdFx0Zmlyc3RIZWFkaW5nLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKGZpcnN0SGVhZGluZylcblx0XHRvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChvYnNlcnZlciA9PSB1bmRlZmluZWQpIHtcblx0XHRuZXcgTXV0YXRpb25PYnNlcnZlcigoXywgb2JzZXJ2ZXIpID0+IHtcblx0XHRcdHVwZGF0ZUhlYWRpbmcoZWxlbSwgdGl0bGUsIG9ic2VydmVyKTtcblx0XHR9KS5vYnNlcnZlKFxuXHRcdFx0ZWxlbSxcblx0XHRcdHsgYXR0cmlidXRlczogZmFsc2UsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9XG5cdFx0KTtcblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcmVwbGFjZUVtYmVkIH0gZnJvbSBcIi4vZW1iZWRzXCI7XG5pbXBvcnQgeyBMaW5rUmFuZ2VTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBwYXJzZUxpbmsgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rUmFuZ2VQb3N0UHJvY2Vzc29yKGVsOiBIVE1MRWxlbWVudCwgc2V0dGluZ3M6IExpbmtSYW5nZVNldHRpbmdzKTogdm9pZCB7XG5cdGNvbnN0IGxpbmtzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYS5pbnRlcm5hbC1saW5rJyk7XG5cblx0Ly8gSGFuZGxlIGxpbmtzXG5cdGxpbmtzLmZvckVhY2gobGluayA9PiB7XG5cdFx0Y29uc3QgaHRtbExpbmsgPSBsaW5rIGFzIEhUTUxFbGVtZW50XG5cdFx0Y29uc3QgcmVzID0gcGFyc2VMaW5rKGFwcCwgaHRtbExpbmssIHNldHRpbmdzKTtcblxuXHRcdGlmIChyZXMgIT09IG51bGwpIHtcblx0XHRcdGlmIChyZXMuYWx0VGV4dCkge1xuXHRcdFx0XHRodG1sTGluay5zZXRUZXh0KHJlcy5hbHRUZXh0KVxuXHRcdFx0fVxuXHRcdFx0aHRtbExpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByZXMubm90ZSArIFwiI1wiICsgcmVzLmgxKTtcblx0XHRcdGh0bWxMaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtaHJlZlwiLCByZXMubm90ZSArIFwiI1wiICsgcmVzLmgxKTtcblx0XHRcdGh0bWxMaW5rLnNldEF0dHJpYnV0ZShcInJhbmdlLWhyZWZcIiwgcmVzLm5vdGUgKyBcIiNcIiArIHJlcy5oMSArIHNldHRpbmdzLmhlYWRpbmdTZXBhcmF0b3IgKyByZXMuaDIpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gSGFuZGxlIGVtYmVkc1xuXHRjb25zdCBlbWJlZHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdzcGFuLmludGVybmFsLWVtYmVkJyk7XG5cdGVtYmVkcy5mb3JFYWNoKGVtYmVkID0+IHtcblx0XHRyZXBsYWNlRW1iZWQoZW1iZWQsIHNldHRpbmdzKVx0XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IEVkaXRvclZpZXcsIERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIFBsdWdpblZhbHVlLCBWaWV3VXBkYXRlIH0gZnJvbSBcIkBjb2RlbWlycm9yL3ZpZXdcIjtcbmltcG9ydCB7IEFwcCwgZWRpdG9yTGl2ZVByZXZpZXdGaWVsZCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgTGlua1JhbmdlU2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgUmFuZ2VTZXRCdWlsZGVyIH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XG5pbXBvcnQgeyByZXBsYWNlRW1iZWQgfSBmcm9tIFwiLi9lbWJlZHNcIjtcblxuZXhwb3J0IGNsYXNzIExpZmVQcmV2aWV3RW1iZWRSZXBsYWNlciBpbXBsZW1lbnRzIFBsdWdpblZhbHVlIHtcblx0ZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQgPSBEZWNvcmF0aW9uLm5vbmU7XG5cdHNldHRpbmdzOiBMaW5rUmFuZ2VTZXR0aW5ncztcblx0YXBwOiBBcHA7XG5cdGVtYmVkQ291bnQ6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3RvcihzZXR0aW5nczogTGlua1JhbmdlU2V0dGluZ3MsIGFwcDogQXBwKSB7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMuZW1iZWRDb3VudCA9IDA7XG5cdH1cblxuXHRidWlsZERlY29yYXRpb25zKHZpZXc6IEVkaXRvclZpZXcsIGVtYmVkczogTm9kZUxpc3QpOiBEZWNvcmF0aW9uU2V0IHtcblx0XHRjb25zdCBidWZmZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyPERlY29yYXRpb24+KClcblx0XHRlbWJlZHMuZm9yRWFjaChlbWJlZCA9PiB7XG5cdFx0XHRyZXBsYWNlRW1iZWQoZW1iZWQsIHRoaXMuc2V0dGluZ3MpXG5cdFx0fSk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5maW5pc2goKTtcblx0fVxuXG5cdHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcblx0XHRpZiAoIXVwZGF0ZS5zdGF0ZS5maWVsZChlZGl0b3JMaXZlUHJldmlld0ZpZWxkKSkge1xuXHRcdFx0Ly8gbGl2ZSBwcmV2aWV3IG9ubHksIG5vdCByZW5kZXJlZCBpbiBzdHJpY3Qgc291cmNlIGNvZGUgdmlld1xuXHRcdFx0dGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgZW1iZWRzID0gdXBkYXRlLnZpZXcuY29udGVudERPTS5xdWVyeVNlbGVjdG9yQWxsKFwiZGl2Lm1hcmtkb3duLWVtYmVkXCIpO1xuXG5cdFx0aWYgKChlbWJlZHMubGVuZ3RoID4gMCAmJiBlbWJlZHMubGVuZ3RoICE9IHRoaXMuZW1iZWRDb3VudCkgfHwgdXBkYXRlLmRvY0NoYW5nZWQpIHtcblx0XHRcdHRoaXMuZW1iZWRDb3VudCA9IGVtYmVkcy5sZW5ndGg7XG5cdFx0XHR0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY29yYXRpb25zKHVwZGF0ZS52aWV3LCBlbWJlZHMpO1xuXHRcdH1cblx0fVx0XG59XG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSB9IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XG5pbXBvcnQgeyBSYW5nZVNldEJ1aWxkZXIgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivc3RhdGVcIjtcbmltcG9ydCB7IHN5bnRheFRyZWUgfSBmcm9tIFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIjtcbmltcG9ydCB7IExpbmtSYW5nZVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IGZpbmRQYXR0ZXJuRm9yRmlsZW5hbWUgYXMgZmluZFBhdHRlcm5Gb3JGaWxlbmFtZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5jbGFzcyBDaGFyYWN0ZXJPdmVyd3JpdGVXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcblxuICAgIHByaXZhdGUgY2hhcjogc3RyaW5nO1xuICAgIGNvbnN0cnVjdG9yKGNoYXI6IHN0cmluZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYXIgPSBjaGFyO1xuICAgIH1cblxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gdGhpcy5jaGFyO1xuICAgICAgICBlbC5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICd1bmRlcmxpbmUnO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDTVZpZXdQbHVnaW4oYXBwOiBBcHAsIHNldHRpbmdzOiBMaW5rUmFuZ2VTZXR0aW5ncykge1xuXG4gICAgY29uc3Qgdmlld1BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKFxuICAgICAgICBjbGFzcyB7XG4gICAgICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvblNldDtcbiAgICAgICAgICAgIGRlY29yYXRlZFJhbmdlczogQXJyYXk8eyBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIgfT47XG4gICAgICAgICAgICBsYXN0TG9jYXRpb246IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyOyB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvcmF0aW9ucyh2aWV3LCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RMb2NhdGlvbiA9IHsgZnJvbTogMCwgdG86IDAgfTs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudExvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1swXS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbMF0udG9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjb3JhdGlvbnModXBkYXRlLnZpZXcsIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc1JlcGVhdFVwZGF0ZSAtIGF2b2lkIHJlcGVhdGVkIHVwZGF0ZXMgYW5kIHJlbmRlcnNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzUmVwZWF0VXBkYXRlID0gdGhpcy5sYXN0TG9jYXRpb24uZnJvbSA9PSBjdXJyZW50TG9jYXRpb24uZnJvbSAmJiB0aGlzLmxhc3RMb2NhdGlvbi50byA9PT0gY3VycmVudExvY2F0aW9uLnRvO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoID4gMCAmJiAhaXNSZXBlYXRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjb3JhdGlvbnModXBkYXRlLnZpZXcsIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1aWxkRGVjb3JhdGlvbnModmlldzogRWRpdG9yVmlldywgbG9jYXRpb246IHsgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyIH0gfCBudWxsKTogRGVjb3JhdGlvblNldCB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyPERlY29yYXRpb24+KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFzc0RlY29yYXRlZFJhbmdlczogQXJyYXk8e2Zyb206IG51bWJlciwgdG86IG51bWJlcn0+ID0gdGhpcy5kZWNvcmF0ZWRSYW5nZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRSYW5nZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluTGFzdFBhc3MgPSBmdW5jdGlvbihub2RlU3RhcnQ6IG51bWJlciwgaW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBsYXN0UGFzc0RlY29yYXRlZFJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm5nID0gbGFzdFBhc3NEZWNvcmF0ZWRSYW5nZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChybmcuZnJvbSA9PSBub2RlU3RhcnQgJiYgaW5kZXggPj0gcm5nLmZyb20gJiYgaW5kZXggPD0gcm5nLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQge2Zyb20sIHRvfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHZpZXcuc3RhdGUpLml0ZXJhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXI6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmlnIHRoYW5rcyB0byBTdXBlcmNoYXJnZWQgTGlua3MuIFVzZWQgeW91ciBjb2RlIGFzIGFuIGV4YW1wbGUhIGh0dHBzOi8vZ2l0aHViLmNvbS9tZGVsb2JlbGxlL29ic2lkaWFuX3N1cGVyY2hhcmdlZF9saW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoZXJlIHVzZWQgdG8gYmUgYSBkaWZmZXJlbnQgd2F5IHRoYW4gc3BsaXR0aW5nIHRoZSBuYW1lIGJ1dCB0aGUgYXBpIGZvciB0aGlzIGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY2hhbmdlZCBpbiBDb2RlTWlycm9yLiBTaG91bGQgbG9vayBpbnRvIGl0IG1vcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Qcm9wcyA9IG5vZGUudHlwZS5uYW1lLnNwbGl0KCdfJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBuZXcgU2V0KHRva2VuUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xpbmsgPSBwcm9wcy5oYXMoXCJobWQtaW50ZXJuYWwtbGlua1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBbGlhcyA9IHByb3BzLmhhcyhcImxpbmstYWxpYXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUGlwZSA9IHByb3BzLmhhcyhcImxpbmstYWxpYXMtcGlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTURVcmwgPSBwcm9wcy5oYXMoJ3VybCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGluayAmJiAhaXNBbGlhcyAmJiAhaXNQaXBlIHx8IGlzTURVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5rVGV4dCA9IHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZIZWFkZXJNYXJrZXIgPSBsaW5rVGV4dC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleE9mSGVhZGVyTWFya2VySW5Eb2MgPSBpbmRleE9mSGVhZGVyTWFya2VyICsgbm9kZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4T2ZIZWFkZXJNYXJrZXJJbkRvYyA+PSBub2RlLmZyb20gJiYgaW5kZXhPZkhlYWRlck1hcmtlckluRG9jIDw9IG5vZGUudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluTGFzdFBhc3Mobm9kZS5mcm9tIC0gMiwgbG9jYXRpb24/LmZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gbGlua1RleHQuc3Vic3RyaW5nKDAsIGluZGV4T2ZIZWFkZXJNYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gZmluZFBhdHRlcm5Gb3JGaWxlbmFtZShmaWxlTmFtZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyB0aGUgaGVhZGluZyBjaGFyYWN0ZXIgKCcjJykgdG8gd2hhdCBpcyBzcGVjaWZpZWQgaW4gc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4uaGVhZGluZ1Zpc3VhbCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdmVycmlkZVAySFdpZGdldCA9IERlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBDaGFyYWN0ZXJPdmVyd3JpdGVXaWRnZXQocGF0dGVybi5oZWFkaW5nVmlzdWFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoaW5kZXhPZkhlYWRlck1hcmtlckluRG9jLCBpbmRleE9mSGVhZGVyTWFya2VySW5Eb2MgKyAxLCBvdmVycmlkZVAySFdpZGdldCk7ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyB0aGUgaGVhZGVyIHNlcGFyYXRvciBjaGFyYWN0ZXIgdG8gd2hhdCBpcyBzcGVjaWZpZWQgaW4gc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4uaGVhZGluZ1NlcGFyYXRvclZpc3VhbCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZSYW5nZU1hcmtlciA9IGxpbmtUZXh0LmluZGV4T2Yoc2V0dGluZ3MuaGVhZGluZ1NlcGFyYXRvcikgKyBub2RlLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZlJhbmdlTWFya2VyID49IG5vZGUuZnJvbSAmJiBpbmRleE9mUmFuZ2VNYXJrZXIgPD0gbm9kZS50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdmVycmlkZUgySFdpZGdldCA9IERlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQ2hhcmFjdGVyT3ZlcndyaXRlV2lkZ2V0KHBhdHRlcm4uaGVhZGluZ1NlcGFyYXRvclZpc3VhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoaW5kZXhPZlJhbmdlTWFya2VyLCBpbmRleE9mUmFuZ2VNYXJrZXIgKyBzZXR0aW5ncy5oZWFkaW5nU2VwYXJhdG9yLmxlbmd0aCwgb3ZlcnJpZGVIMkhXaWRnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IG5vZGUuZnJvbSAtIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBub2RlLnRvICsgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyZWREZWNzID0gYnVpbGRlci5maW5pc2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyZWREZWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHZpZXdQbHVnaW47XG59ICJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQXVCOzs7QUNBaEIsU0FBUyxPQUFPLEtBQUssV0FBVztBQUNuQyxRQUFNLFdBQVcsT0FBTyxLQUFLLFNBQVMsRUFBRSxJQUFJLFNBQU8sUUFBUSxLQUFLLEtBQUssVUFBVSxHQUFHLENBQUMsQ0FBQztBQUNwRixTQUFPLFNBQVMsV0FBVyxJQUFJLFNBQVMsQ0FBQyxJQUFJLFdBQVk7QUFBRSxhQUFTLFFBQVEsT0FBSyxFQUFFLENBQUM7QUFBQSxFQUFHO0FBQzNGO0FBQ0EsU0FBUyxRQUFRLEtBQUssUUFBUSxlQUFlO0FBQ3pDLFFBQU0sV0FBVyxJQUFJLE1BQU0sR0FBRyxTQUFTLElBQUksZUFBZSxNQUFNO0FBQ2hFLE1BQUksVUFBVSxjQUFjLFFBQVE7QUFHcEMsTUFBSTtBQUNBLFdBQU8sZUFBZSxTQUFTLFFBQVE7QUFDM0MsU0FBTyxlQUFlLFNBQVMsT0FBTztBQUN0QyxNQUFJLE1BQU0sSUFBSTtBQUVkLFNBQU87QUFDUCxXQUFTLFdBQVcsTUFBTTtBQUV0QixRQUFJLFlBQVksWUFBWSxJQUFJLE1BQU0sTUFBTTtBQUN4QyxhQUFPO0FBQ1gsV0FBTyxRQUFRLE1BQU0sTUFBTSxJQUFJO0FBQUEsRUFDbkM7QUFDQSxXQUFTLFNBQVM7QUFFZCxRQUFJLElBQUksTUFBTSxNQUFNLFNBQVM7QUFDekIsVUFBSTtBQUNBLFlBQUksTUFBTSxJQUFJO0FBQUE7QUFFZCxlQUFPLElBQUksTUFBTTtBQUFBLElBQ3pCO0FBQ0EsUUFBSSxZQUFZO0FBQ1o7QUFFSixjQUFVO0FBQ1YsV0FBTyxlQUFlLFNBQVMsWUFBWSxRQUFRO0FBQUEsRUFDdkQ7QUFDSjs7O0FEakNBLElBQUFDLGVBQTJCOzs7QUVEM0Isc0JBQWdFOzs7QUNDaEUsV0FBc0I7QUFxQnRCLFNBQVMsY0FBYyxNQUFjLFVBQWdEO0FBQ3BGLFFBQU0sWUFBWTtBQUVsQixRQUFNLFVBQVUsVUFBVSxLQUFLLElBQUk7QUFFbkMsTUFBSSxXQUFXLFFBQVEsUUFBUSxTQUFTLEtBQUssUUFBUSxDQUFDLEtBQUssUUFBVztBQUNyRSxXQUFPO0FBQUEsRUFDUjtBQUVBLFFBQU0sT0FBTyxRQUFRLENBQUM7QUFHdEIsUUFBTSxjQUFjLE9BQU87QUFDM0IsUUFBTSxXQUFnQixjQUFTLElBQUk7QUFDbEMsUUFBTSxPQUEwQixJQUFJLE1BQU0saUJBQWlCLEVBQUU7QUFBQSxJQUM3RCxPQUFLLEVBQUUsWUFBWSxZQUFZLEVBQUUsS0FBSyxTQUFTLFdBQVc7QUFBQSxFQUMzRCxFQUFFLE1BQU07QUFFUixNQUFJLENBQUM7QUFBTSxXQUFPO0FBRWxCLFFBQU0sVUFBVSxtQkFBbUIsTUFBTSxRQUFRO0FBRWpELFFBQU0sUUFBUSxRQUFRLENBQUMsRUFBRSxNQUFNLFNBQVMsZ0JBQWdCO0FBQ3hELFFBQU0sS0FBSyxNQUFNLENBQUM7QUFDbEIsUUFBTSxLQUFLLE1BQU0sQ0FBQztBQUdsQixNQUFJLFVBQVU7QUFDZCxNQUFJLFFBQVEsU0FBUyxLQUFLLFFBQVEsQ0FBQyxLQUFLLFFBQVc7QUFDbEQsY0FBVSxRQUFRLENBQUM7QUFBQSxFQUNwQixPQUFPO0FBQ04sVUFBTSxnQkFBZ0IsUUFBUSxrQkFBa0IsS0FBSyxNQUFNLFFBQVE7QUFDbkUsVUFBTSx5QkFBeUIsUUFBUSwyQkFBMkIsS0FBSyxTQUFTLG1CQUFtQixRQUFRO0FBQzNHLFFBQUksT0FBTyxRQUFXO0FBQ3JCLGdCQUFVLEdBQUcsV0FBVyxnQkFBZ0IsS0FBSyx5QkFBeUI7QUFBQSxJQUN2RSxPQUFPO0FBQ04sZ0JBQVUsR0FBRyxXQUFXLGdCQUFnQjtBQUFBLElBQ3pDO0FBQUEsRUFDRDtBQUVBLFNBQU87QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQTtBQUFBLElBRUEsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLEVBQ1Q7QUFDRDtBQUVPLFNBQVMsVUFBVUMsTUFBVSxVQUF1QixVQUE2QixVQUFRLE9BQU8sWUFBWSxhQUFnQztBQTVFbko7QUE2RUMsUUFBTSxPQUFPLFNBQVMsYUFBYSxTQUFTO0FBRTVDLE1BQUksUUFBUTtBQUFNLFdBQU87QUFFekIsUUFBTSxNQUFNLGNBQWMsTUFBTSxRQUFRO0FBQ3hDLE1BQUksQ0FBQyxPQUFPQSxLQUFJLGlCQUFpQjtBQUFNLFdBQU87QUFFOUMsUUFBTSxNQUFNLFNBQVMsYUFBYSxLQUFLO0FBR3ZDLE1BQUksT0FBTyxRQUFRLENBQUMsSUFBSSxTQUFTLElBQUksSUFBSSxHQUFHO0FBQzNDLFFBQUksVUFBVTtBQUFBLEVBQ2Y7QUFFQSxNQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsVUFBVSxTQUFTLElBQUksSUFBSSxHQUFHO0FBQ3ZELFFBQUksVUFBVSxTQUFTO0FBQUEsRUFDeEI7QUFFQSxRQUFNLE9BQU9BLEtBQUksY0FBYyxhQUFhLElBQUksSUFBSTtBQUVwRCxNQUFJLFFBQVEsVUFBYSxLQUFLLFlBQVksUUFBVztBQUNwRCxXQUFPO0FBQUEsRUFDUjtBQUdBLFFBQU0sVUFBUyx3Q0FBTSxhQUFOLG1CQUFnQjtBQUFBLElBQzlCLE9BQUssRUFBRSxXQUFXLElBQUk7QUFBQSxJQUNyQixZQUZhLG1CQUVKLFNBQVMsTUFBTTtBQUMxQixNQUFJLFVBQVU7QUFBVyxXQUFPO0FBQ2hDLE1BQUksU0FBUztBQUdiLE1BQUksSUFBSSxPQUFPLFFBQVc7QUFDekIsUUFBSSxTQUFTLGNBQWM7QUFDMUIsVUFBSSxlQUFjLGtDQUFNLGFBQU4sbUJBQWdCLFVBQVUsT0FBSyxFQUFFLFdBQVcsSUFBSTtBQUVsRSxZQUFJLGtDQUFNLGFBQU4sbUJBQWdCLFVBQVMsYUFBYTtBQUN6Qyx1QkFBZTtBQUFBLE1BQ2hCO0FBRUEsVUFBSSxVQUFTLHdDQUFNLGFBQU4sbUJBQWdCLEdBQUcsaUJBQW5CLG1CQUFpQyxTQUFTLElBQUk7QUFBQSxJQUM1RCxPQUFPO0FBQ04sVUFBSSxVQUFTLHdDQUFNLGFBQU4sbUJBQWdCO0FBQUEsUUFDNUIsT0FBSyxFQUFFLFdBQVcsSUFBSTtBQUFBLFFBQ3JCLFlBRlcsbUJBRUYsU0FBUyxJQUFJO0FBQUEsSUFDekI7QUFBQSxFQUNEO0FBRUEsU0FBTztBQUNSO0FBRU8sU0FBUyxvQkFBb0JBLE1BQVU7QUFDN0MsYUFBVyxRQUFRQSxLQUFJLFVBQVUsZ0JBQWdCLFVBQVUsR0FBRztBQUU3RCxVQUFNLE9BQU8sS0FBSztBQUVsQixTQUFLLFlBQVksU0FBUyxNQUFNO0FBQ2hDLFNBQUssWUFBWSxTQUFTLElBQUksS0FBSyxPQUFPLEdBQUcsTUFBTSxJQUFJLFNBQVMsQ0FBQztBQUFBLEVBQ2xFO0FBRUEsRUFBQUEsS0FBSSxVQUFVLGNBQWM7QUFDN0I7QUFFTyxTQUFTLHVCQUF1QixVQUFrQixVQUF1QztBQUMvRixRQUFNLE9BQU8sSUFBSSxNQUFNLFNBQVMsRUFBRSxLQUFLLENBQUNDLFVBQVNBLE1BQUssYUFBYSxRQUFRO0FBQzNFLFNBQU8sbUJBQW1CLE1BQU0sUUFBUTtBQUN6QztBQUVBLFNBQVMsbUJBQW1CLE1BQXlCLFVBQXVDO0FBQzNGLE1BQUksTUFBTTtBQUNULFFBQUksVUFBVSxDQUFDLEdBQUcsU0FBUyxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQUEsTUFBSyxDQUFDQyxhQUNwRCxLQUFLLEtBQUssV0FBV0EsU0FBUSxJQUFJO0FBQUEsSUFDbEM7QUFDQSxRQUFJO0FBQVMsYUFBTztBQUFBLEVBQ3JCO0FBRUEsU0FBTyxTQUFTLGtCQUFrQjtBQUNuQzs7O0FEdklPLElBQU0sbUJBQXNDO0FBQUEsRUFDbEQsa0JBQWtCO0FBQUEsRUFDbEIsY0FBYztBQUFBLEVBQ2QsV0FBVztBQUFBLEVBQ1gsaUJBQWlCO0FBQUEsRUFDakIsVUFBVSxDQUFDLEVBQUUsZUFBZSxNQUFNLHdCQUF3QixLQUFLLE1BQU0sSUFBSSxDQUFDO0FBQUEsRUFFMUUsb0JBQW9CO0FBQ25CLFVBQU0sUUFBUSxLQUFLLFNBQVMsQ0FBQztBQUM3QixRQUFJLENBQUMsT0FBTztBQUNYLGFBQU8sRUFBRSxlQUFlLEtBQUssd0JBQXdCLEtBQUssTUFBTSxJQUFJO0FBQUEsSUFDckU7QUFFQSxXQUFPO0FBQUEsRUFDUjtBQUNEO0FBRU8sSUFBTSxzQkFBTixjQUFrQyxpQ0FBaUI7QUFBQSxFQUd6RCxZQUFZQyxNQUFVLFFBQW1CO0FBQ3hDLFVBQU1BLE1BQUssTUFBTTtBQUNqQixTQUFLLFNBQVM7QUFDZCxTQUFLLG1CQUFtQjtBQUFBLEVBQ3pCO0FBQUEsRUFFQSxxQkFBcUI7QUFDcEIsVUFBTSxPQUFPLEtBQUssT0FBTztBQUV6QixVQUFNLGdCQUFnQixLQUFLLGFBQWEsVUFBYSxLQUFLLFVBQVUsU0FBUztBQUM3RSxRQUFJLGVBQWU7QUFHbEIsWUFBTSxZQUFZLEtBQUs7QUFDdkIsWUFBTSxjQUFjLFVBQVUsUUFBUSxPQUFPO0FBQzdDLFlBQU0sWUFBWSxVQUFVLFFBQVEsS0FBSztBQUN6QyxZQUFNLFlBQVksVUFBVSxRQUFRLEtBQUs7QUFFekMsWUFBTSxnQkFBZ0IsZ0JBQWdCLEtBQUssY0FBYyxNQUFNLGNBQWM7QUFFN0UsVUFBSSxlQUFlO0FBQ2xCLGNBQU0sYUFBYSxVQUFVLFVBQVUsUUFBUSxRQUFRLFNBQVM7QUFDaEUsY0FBTSxjQUFjLFVBQVUsVUFBVSxZQUFZLE1BQU0sUUFBUSxTQUFTO0FBRTNFLGFBQUssV0FBVyxDQUFDLEVBQUUsZUFBZSxZQUFZLHdCQUF3QixhQUFhLE1BQU0sR0FBRyxDQUFDO0FBQUEsTUFDOUY7QUFFQSxXQUFLLFlBQVk7QUFDakIsV0FBSyxPQUFPLGFBQWE7QUFBQSxJQUMxQjtBQUFBLEVBQ0Q7QUFBQSxFQUVBLFVBQWdCO0FBQ2YsVUFBTSxFQUFDLFlBQVcsSUFBSTtBQUV0QixnQkFBWSxNQUFNO0FBRWxCLFNBQUssU0FBUyxnQ0FBZ0M7QUFFOUMsUUFBSSx3QkFBUSxXQUFXLEVBQ3JCLFFBQVEsbUJBQW1CLEVBQzNCLFFBQVEsK0dBQStHLEVBQ3ZILFFBQVEsVUFBUSxLQUNmLGVBQWUsMkNBQTJDLEVBQzFELFNBQVMsS0FBSyxPQUFPLFNBQVMsZ0JBQWdCLEVBQzlDLFNBQVMsT0FBTyxVQUFVO0FBQzFCLFdBQUssT0FBTyxTQUFTLG1CQUFtQjtBQUN4QyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLDBCQUFvQixLQUFLLEdBQUc7QUFBQSxJQUM3QixDQUFDLENBQUM7QUFFSixRQUFJLHdCQUFRLFdBQVcsRUFDckIsUUFBUSxlQUFlLEVBQ3ZCLFFBQVEsaUVBQWlFLEVBQ3pFLFVBQVUsVUFBUSxLQUNqQixTQUFTLEtBQUssT0FBTyxTQUFTLFlBQVksRUFDMUMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsV0FBSyxPQUFPLFNBQVMsZUFBZTtBQUNwQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLDBCQUFvQixLQUFLLEdBQUc7QUFBQSxJQUM3QixDQUFDLENBQUM7QUFFSixRQUFJLHdCQUFRLEtBQUssV0FBVyxFQUMxQixRQUFRLDBCQUEwQixFQUNsQyxRQUFRLGdWQUFnVixFQUN4VixVQUFVLENBQUMsV0FBNEI7QUFDdkMsYUFDRSxXQUFXLGdEQUFnRCxFQUMzRCxjQUFjLEdBQUcsRUFDakIsT0FBTyxFQUNQLFFBQVEsTUFBTTtBQUNkLGFBQUssT0FBTyxTQUFTLFNBQVMsS0FBSztBQUFBLFVBQ2xDLGVBQWU7QUFBQSxVQUNmLHdCQUF3QjtBQUFBLFVBQ3hCLE1BQU07QUFBQSxRQUNQLENBQUM7QUFDRCxhQUFLLE9BQU8sYUFBYTtBQUN6QixhQUFLLFFBQVE7QUFBQSxNQUNkLENBQUM7QUFBQSxJQUNILENBQUM7QUFFRCxTQUFLLE9BQU8sU0FBUyxTQUFTO0FBQUEsTUFDN0IsQ0FBQyxTQUFTLFVBQVU7QUFDbkIsY0FBTSxJQUFJLElBQUksd0JBQVEsS0FBSyxXQUFXLEVBQ3JDLFFBQVEsVUFBUSxLQUNmLGVBQWUsMEJBQTBCLEVBQ3pDLFNBQVMsUUFBUSxhQUFhLEVBQzlCLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGtCQUFRLGdCQUFnQjtBQUN4QixnQkFBTSxLQUFLLE9BQU8sYUFBYTtBQUMvQiw4QkFBb0IsS0FBSyxHQUFHO0FBQUEsUUFDN0IsQ0FBQyxDQUFDLEVBQ0YsUUFBUSxVQUFRLEtBQ2YsZUFBZSw0QkFBNEIsRUFDM0MsU0FBUyxRQUFRLHNCQUFzQixFQUN2QyxTQUFTLE9BQU8sVUFBVTtBQUMxQixrQkFBUSx5QkFBeUI7QUFDakMsZ0JBQU0sS0FBSyxPQUFPLGFBQWE7QUFDL0IsOEJBQW9CLEtBQUssR0FBRztBQUFBLFFBQzdCLENBQUMsQ0FBQyxFQUNGLFFBQVEsVUFBUSxLQUNmLGVBQWUsVUFBVSxJQUFJLGFBQWEsY0FBYyxFQUN4RCxTQUFTLFFBQVEsSUFBSSxFQUNyQixZQUFZLFVBQVUsQ0FBQyxFQUN2QixTQUFTLE9BQU8sVUFBVTtBQUMxQixrQkFBUSxPQUFPO0FBQ2YsZ0JBQU0sS0FBSyxPQUFPLGFBQWE7QUFDL0IsOEJBQW9CLEtBQUssR0FBRztBQUFBLFFBQzdCLENBQUMsQ0FBQztBQUVILFlBQUksVUFBVSxHQUFHO0FBQ2hCLFlBQUUsZUFBZSxDQUFDLE9BQU87QUFDeEIsZUFBRyxRQUFRLE1BQU0sRUFDZixXQUFXLHFEQUFxRDtBQUFBLFVBQ25FLENBQUM7QUFBQSxRQUNGLE9BQ0s7QUFDSixjQUFJLFVBQVUsR0FBRztBQUNoQixjQUFFLGVBQWUsQ0FBQyxPQUFPO0FBQ3hCLGlCQUFHLFFBQVEsT0FBTyxFQUNoQixXQUFXLFFBQVEsRUFDbkIsUUFBUSxNQUFNO0FBQ2QscUJBQUssT0FBTyxTQUFTLFNBQVM7QUFBQSxrQkFDN0I7QUFBQSxrQkFDQTtBQUFBLGdCQUNEO0FBQ0EscUJBQUssT0FBTyxhQUFhO0FBQ3pCLHFCQUFLLFFBQVE7QUFBQSxjQUNkLENBQUM7QUFBQSxZQUVILENBQUM7QUFBQSxVQUNGO0FBQUEsUUFDRDtBQUFBLE1BQ0Q7QUFBQSxJQUNEO0FBQUEsRUFDRjtBQUFBLEVBRUEsU0FBUyxNQUFjO0FBQ3RCLFVBQU0sRUFBQyxZQUFXLElBQUk7QUFDdEIsZ0JBQVksU0FBUyxNQUFNLEVBQUUsS0FBVyxDQUFDO0FBQUEsRUFDMUM7QUFHRDs7O0FFdExBLElBQUFDLG1CQUFzRDtBQUl0RCxlQUFzQixhQUFhLE9BQWEsVUFBNkI7QUFDNUUsTUFBSSxZQUFZO0FBRWhCLFFBQU0sT0FBTyxVQUFVLEtBQUssV0FBVyxVQUFVLE1BQU0sS0FBSztBQUM1RCxNQUFJLFFBQVEsUUFBVztBQUN0QjtBQUFBLEVBQ0Q7QUFDQSxRQUFNLGNBQWMsS0FBSyxPQUFPO0FBRWhDLE1BQUksQ0FBQyxhQUFhO0FBQ2pCLFFBQUksS0FBSyxZQUFZLFNBQVMsa0JBQWtCLEdBQUc7QUFDbEQsb0JBQWMsV0FBVyxLQUFLLE9BQU87QUFBQSxJQUN0QztBQUNBO0FBQUEsRUFDRDtBQUVBLFFBQU0sRUFBRSxNQUFNLElBQUk7QUFFbEIsZ0JBQWMsV0FBVyxLQUFLLE9BQU87QUFFckMsUUFBTSxhQUFhLFVBQVUsY0FBYyw0QkFBNEI7QUFDdkUsTUFBSSxjQUFjLFFBQVEsRUFBRSxzQkFBc0I7QUFBYztBQUNoRSxTQUFPLFdBQVcsa0JBQWtCO0FBQ25DLGVBQVcsWUFBWSxXQUFXLGdCQUFnQjtBQUFBLEVBQ25EO0FBQ0EsYUFBVyxXQUFXLFFBQVEsT0FBSztBQUFFLE1BQUUsT0FBTztBQUFBLEVBQUUsQ0FBQztBQUVqRCxRQUFNLGNBQWMsTUFBTSxNQUFNLFdBQVcsS0FBSyxJQUFJO0FBQ3BELE1BQUksUUFBUSxZQUFZLE1BQU0sSUFBSTtBQUNsQyxVQUFRLE1BQU0sTUFBTSxLQUFLLFFBQVEsS0FBSyxNQUFNO0FBQzVDLG9DQUFpQixlQUFlLE1BQU0sS0FBSyxJQUFJLEdBQUcsWUFBWSxJQUFJLElBQUs7QUFFdkUsUUFBTSxVQUFVLFVBQVUsY0FBYyx5QkFBeUI7QUFDakUsTUFBSSxtQkFBbUIsYUFBYTtBQUNuQyxVQUFNLFVBQVUsUUFBUSxVQUFVLElBQUk7QUFDdEMsWUFBUSxZQUFZLE9BQU87QUFDM0IsWUFBUSxhQUFhLENBQUMsT0FBbUI7QUFDeEMsWUFBTSxPQUFPLElBQUksVUFBVSxrQkFBa0I7QUFFN0MsWUFBTSxXQUFXLE9BQU8sT0FBTyxFQUFFLE1BQU0sR0FBRyxLQUFLLEdBQUcsUUFBUSxFQUFFLEdBQUcsQ0FBQztBQUNoRSxZQUFNLFNBQVMsT0FBTyxPQUFPLEVBQUUsTUFBTSxHQUFHLEtBQUssR0FBRyxRQUFRLEVBQUUsR0FBRyxDQUFDO0FBQzlELFlBQU0sRUFBRSxNQUFNLElBQUksSUFBSTtBQUN0QixZQUFNLFFBQVE7QUFBQSxRQUNiLFFBQVE7QUFBQSxVQUNQO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBLFFBQVE7QUFBQSxZQUNQLE1BQU0sRUFBRSxNQUFNLElBQUksRUFBRTtBQUFBLFlBQ3BCLElBQUksRUFBRSxNQUFNLElBQUksRUFBRTtBQUFBLFVBQ25CO0FBQUEsUUFDRDtBQUFBLE1BQ0Q7QUFFQSxtQ0FBTSxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzNCLENBQUM7QUFBQSxFQUNGO0FBQ0Q7QUFFQSxTQUFTLGNBQ1IsTUFDQSxPQUNBLFdBQXlDLFFBQ3hDO0FBbkVGO0FBb0VDLFFBQU0sWUFBWSxLQUFLLGNBQWMsbUNBQW1DO0FBQ3hFLFFBQU0sZUFBZSxLQUFLLGNBQWMsbUJBQW1CO0FBQzNELE1BQUksYUFBYSxRQUFRLGdCQUFnQixNQUFNO0FBQzlDLGNBQVUsUUFBUSxLQUFLO0FBQ3ZCLHVCQUFhLGVBQWIsbUJBQXlCLFlBQVk7QUFDckMseUNBQVU7QUFDVjtBQUFBLEVBQ0Q7QUFFQSxNQUFJLFlBQVksUUFBVztBQUMxQixRQUFJLGlCQUFpQixDQUFDLEdBQUdDLGNBQWE7QUFDckMsb0JBQWMsTUFBTSxPQUFPQSxTQUFRO0FBQUEsSUFDcEMsQ0FBQyxFQUFFO0FBQUEsTUFDRjtBQUFBLE1BQ0EsRUFBRSxZQUFZLE9BQU8sV0FBVyxNQUFNLFNBQVMsS0FBSztBQUFBLElBQ3JEO0FBQUEsRUFDRDtBQUNEOzs7QUMvRU8sU0FBUyx1QkFBdUIsSUFBaUIsVUFBbUM7QUFDMUYsUUFBTSxRQUFRLEdBQUcsaUJBQWlCLGlCQUFpQjtBQUduRCxRQUFNLFFBQVEsVUFBUTtBQUNyQixVQUFNLFdBQVc7QUFDakIsVUFBTSxNQUFNLFVBQVUsS0FBSyxVQUFVLFFBQVE7QUFFN0MsUUFBSSxRQUFRLE1BQU07QUFDakIsVUFBSSxJQUFJLFNBQVM7QUFDaEIsaUJBQVMsUUFBUSxJQUFJLE9BQU87QUFBQSxNQUM3QjtBQUNBLGVBQVMsYUFBYSxRQUFRLElBQUksT0FBTyxNQUFNLElBQUksRUFBRTtBQUNyRCxlQUFTLGFBQWEsYUFBYSxJQUFJLE9BQU8sTUFBTSxJQUFJLEVBQUU7QUFDMUQsZUFBUyxhQUFhLGNBQWMsSUFBSSxPQUFPLE1BQU0sSUFBSSxLQUFLLFNBQVMsbUJBQW1CLElBQUksRUFBRTtBQUFBLElBQ2pHO0FBQUEsRUFDRCxDQUFDO0FBR0QsUUFBTSxTQUFTLEdBQUcsaUJBQWlCLHFCQUFxQjtBQUN4RCxTQUFPLFFBQVEsV0FBUztBQUN2QixpQkFBYSxPQUFPLFFBQVE7QUFBQSxFQUM3QixDQUFDO0FBQ0Y7OztBQzdCQSxrQkFBK0U7QUFDL0UsSUFBQUMsbUJBQTRDO0FBRTVDLG1CQUFnQztBQUd6QixJQUFNLDJCQUFOLE1BQXNEO0FBQUEsRUFNNUQsWUFBWSxVQUE2QkMsTUFBVTtBQUxuRCx1QkFBNkIsdUJBQVc7QUFNdkMsU0FBSyxXQUFXO0FBQ2hCLFNBQUssTUFBTUE7QUFDWCxTQUFLLGFBQWE7QUFBQSxFQUNuQjtBQUFBLEVBRUEsaUJBQWlCLE1BQWtCLFFBQWlDO0FBQ25FLFVBQU0sU0FBUyxJQUFJLDZCQUE0QjtBQUMvQyxXQUFPLFFBQVEsV0FBUztBQUN2QixtQkFBYSxPQUFPLEtBQUssUUFBUTtBQUFBLElBQ2xDLENBQUM7QUFDRCxXQUFPLE9BQU8sT0FBTztBQUFBLEVBQ3RCO0FBQUEsRUFFQSxPQUFPLFFBQW9CO0FBQzFCLFFBQUksQ0FBQyxPQUFPLE1BQU0sTUFBTSx1Q0FBc0IsR0FBRztBQUVoRCxXQUFLLGNBQWMsdUJBQVc7QUFDOUI7QUFBQSxJQUNEO0FBQ0EsVUFBTSxTQUFTLE9BQU8sS0FBSyxXQUFXLGlCQUFpQixvQkFBb0I7QUFFM0UsUUFBSyxPQUFPLFNBQVMsS0FBSyxPQUFPLFVBQVUsS0FBSyxjQUFlLE9BQU8sWUFBWTtBQUNqRixXQUFLLGFBQWEsT0FBTztBQUN6QixXQUFLLGNBQWMsS0FBSyxpQkFBaUIsT0FBTyxNQUFNLE1BQU07QUFBQSxJQUM3RDtBQUFBLEVBQ0Q7QUFDRDs7O0FDdENBLElBQUFDLGVBQTBGO0FBQzFGLElBQUFDLGdCQUFnQztBQUNoQyxzQkFBMkI7QUFJM0IsSUFBTSwyQkFBTixjQUF1Qyx3QkFBVztBQUFBLEVBRzlDLFlBQVksTUFBYztBQUN0QixVQUFNO0FBQ04sU0FBSyxPQUFPO0FBQUEsRUFDaEI7QUFBQSxFQUVBLFFBQVE7QUFDSixRQUFJLEtBQUssU0FBUyxjQUFjLE1BQU07QUFDdEMsT0FBRyxZQUFZLEtBQUs7QUFDcEIsT0FBRyxNQUFNLGlCQUFpQjtBQUMxQixXQUFPO0FBQUEsRUFDWDtBQUNKO0FBRU8sU0FBUyxrQkFBa0JDLE1BQVUsVUFBNkI7QUFFckUsUUFBTSxhQUFhLHdCQUFXO0FBQUEsSUFDMUIsTUFBTTtBQUFBLE1BS0YsWUFBWSxNQUFrQjtBQUMxQixhQUFLLGNBQWMsS0FBSyxpQkFBaUIsTUFBTSxJQUFJO0FBQ25ELGFBQUssZUFBZSxFQUFFLE1BQU0sR0FBRyxJQUFJLEVBQUU7QUFBRTtBQUFBLE1BQzNDO0FBQUEsTUFFQSxPQUFPLFFBQW9CO0FBQ3ZCLFlBQUksa0JBQWtCO0FBQUEsVUFDbEIsTUFBTSxPQUFPLE1BQU0sVUFBVSxPQUFPLENBQUMsRUFBRTtBQUFBLFVBQ3ZDLElBQUksT0FBTyxNQUFNLFVBQVUsT0FBTyxDQUFDLEVBQUU7QUFBQSxRQUN6QztBQUNBLFlBQUksT0FBTyxjQUFjLE9BQU8saUJBQWlCO0FBQzdDLGVBQUssY0FBYyxLQUFLLGlCQUFpQixPQUFPLE1BQU0sZUFBZTtBQUFBLFFBQ3pFLE9BQ0s7QUFFRCxjQUFJLGlCQUFpQixLQUFLLGFBQWEsUUFBUSxnQkFBZ0IsUUFBUSxLQUFLLGFBQWEsT0FBTyxnQkFBZ0I7QUFDaEgsY0FBSSxPQUFPLE1BQU0sVUFBVSxPQUFPLFNBQVMsS0FBSyxDQUFDLGdCQUFnQjtBQUM3RCxpQkFBSyxjQUFjLEtBQUssaUJBQWlCLE9BQU8sTUFBTSxlQUFlO0FBQUEsVUFDekU7QUFBQSxRQUNKO0FBQ0EsYUFBSyxlQUFlO0FBQUEsTUFDeEI7QUFBQSxNQUVBLGlCQUFpQixNQUFrQixVQUE4RDtBQUM3RixZQUFJLFVBQVUsSUFBSSw4QkFBNEI7QUFFOUMsY0FBTSwwQkFBNkQsS0FBSztBQUN4RSxhQUFLLGtCQUFrQixDQUFDO0FBRXhCLGNBQU0sYUFBYSxTQUFTLFdBQW1CLE9BQW9DO0FBQy9FLGNBQUksVUFBVSxRQUFXO0FBQ3JCLG1CQUFPO0FBQUEsVUFDWDtBQUVBLG1CQUFTLEtBQUsseUJBQXlCO0FBQ25DLGtCQUFNLE1BQU0sd0JBQXdCLENBQUM7QUFFckMsZ0JBQUksSUFBSSxRQUFRLGFBQWEsU0FBUyxJQUFJLFFBQVEsU0FBUyxJQUFJLElBQUk7QUFDbkUscUJBQU87QUFBQSxZQUNQO0FBQUEsVUFDSjtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUVBLGlCQUFTLEVBQUMsTUFBTSxHQUFFLEtBQUssS0FBSyxlQUFlO0FBRXZDLDBDQUFXLEtBQUssS0FBSyxFQUFFLFFBQVE7QUFBQSxZQUMzQjtBQUFBLFlBQ0E7QUFBQSxZQUNBLE9BQU8sQ0FBQyxTQUFTO0FBS2Isb0JBQU0sYUFBYSxLQUFLLEtBQUssS0FBSyxNQUFNLEdBQUc7QUFDM0Msa0JBQUksWUFBWTtBQUNaLHNCQUFNLFFBQVEsSUFBSSxJQUFJLFVBQVU7QUFDaEMsc0JBQU0sU0FBUyxNQUFNLElBQUksbUJBQW1CO0FBQzVDLHNCQUFNLFVBQVUsTUFBTSxJQUFJLFlBQVk7QUFDdEMsc0JBQU0sU0FBUyxNQUFNLElBQUksaUJBQWlCO0FBRTFDLHNCQUFNLFVBQVUsTUFBTSxJQUFJLEtBQUs7QUFFL0Isb0JBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxVQUFVLFNBQVM7QUFDMUMsc0JBQUksV0FBVyxLQUFLLE1BQU0sSUFBSSxZQUFZLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFFNUQsd0JBQU0sc0JBQXNCLFNBQVMsUUFBUSxHQUFHO0FBQ2hELHdCQUFNLDJCQUEyQixzQkFBc0IsS0FBSztBQUM1RCxzQkFBSSw0QkFBNEIsS0FBSyxRQUFRLDRCQUE0QixLQUFLLElBQUk7QUFDOUUsd0JBQUksQ0FBQyxXQUFXLEtBQUssT0FBTyxHQUFHLHFDQUFVLElBQUksR0FBRztBQUU1Qyw0QkFBTSxXQUFXLFNBQVMsVUFBVSxHQUFHLG1CQUFtQjtBQUMxRCw0QkFBTSxVQUFVLHVCQUF1QixVQUFVLFFBQVE7QUFHekQsMEJBQUksUUFBUSxrQkFBa0IsSUFBSTtBQUM5Qiw0QkFBSSxvQkFBb0Isd0JBQVcsT0FBTztBQUFBLDBCQUN0QyxRQUFRLElBQUkseUJBQXlCLFFBQVEsYUFBYTtBQUFBLHdCQUM5RCxDQUFDO0FBQ0QsZ0NBQVEsSUFBSSwwQkFBMEIsMkJBQTJCLEdBQUcsaUJBQWlCO0FBQUEsc0JBQ3pGO0FBR0EsMEJBQUksUUFBUSwyQkFBMkIsSUFBSTtBQUN2Qyw4QkFBTSxxQkFBcUIsU0FBUyxRQUFRLFNBQVMsZ0JBQWdCLElBQUksS0FBSztBQUM5RSw0QkFBSSxzQkFBc0IsS0FBSyxRQUFRLHNCQUFzQixLQUFLLElBQUk7QUFDbEUsOEJBQUksb0JBQW9CLHdCQUFXLE9BQU87QUFBQSw0QkFDdEMsUUFBUSxJQUFJLHlCQUF5QixRQUFRLHNCQUFzQjtBQUFBLDBCQUN2RSxDQUFDO0FBQ0Qsa0NBQVEsSUFBSSxvQkFBb0IscUJBQXFCLFNBQVMsaUJBQWlCLFFBQVEsaUJBQWlCO0FBQUEsd0JBQzVHO0FBQUEsc0JBQ0o7QUFBQSxvQkFDSjtBQUVBLHlCQUFLLGdCQUFnQixLQUFLO0FBQUEsc0JBQ3RCLE1BQU0sS0FBSyxPQUFPO0FBQUEsc0JBQ2xCLElBQUksS0FBSyxLQUFLO0FBQUEsb0JBQ2xCLENBQUM7QUFBQSxrQkFDTDtBQUFBLGdCQUNKO0FBQUEsY0FDSjtBQUFBLFlBQ0o7QUFBQSxVQUNKLENBQUM7QUFBQSxRQUNMO0FBRUEsY0FBTSxlQUFlLFFBQVEsT0FBTztBQUNwQyxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUEsTUFDSSxhQUFhLE9BQUssRUFBRTtBQUFBLElBQ3hCO0FBQUEsRUFDSjtBQUVBLFNBQU87QUFDWDs7O0FQMUlBLElBQUFDLGdCQUFxQjtBQUVyQixJQUFxQixZQUFyQixjQUF1Qyx3QkFBTztBQUFBLEVBRzdDLE1BQU0sU0FBUztBQUNkLFVBQU0sS0FBSyxhQUFhO0FBR3hCLFNBQUssY0FBYyxJQUFJLG9CQUFvQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBRTFELFVBQU0sV0FBVyxLQUFLO0FBRXRCLFNBQUssOEJBQThCLENBQUMsT0FBTztBQUMxQyw2QkFBdUIsSUFBSSxRQUFRO0FBQUEsSUFDcEMsQ0FBQztBQUdELFNBQUssSUFBSSxVQUFVLGNBQWMsTUFBTTtBQUN0QyxXQUFLLHdCQUF3Qix3QkFBVyxPQUFPLENBQUMsTUFBTTtBQUNyRCxlQUFPLElBQUkseUJBQXlCLEtBQUssVUFBVSxLQUFLLEdBQUc7QUFBQSxNQUM1RCxDQUFDLENBQUM7QUFFRixZQUFNLE1BQU0sbUJBQUssT0FBTyxrQkFBa0IsS0FBSyxLQUFLLEtBQUssUUFBUSxDQUFDO0FBQ2xFLFdBQUssd0JBQXdCLEdBQUc7QUFFaEMsWUFBTSxvQkFBb0IsS0FBSyxJQUFJLGdCQUFnQixRQUFRLGNBQWM7QUFHekUsWUFBTSxjQUFjLE9BQU8sa0JBQWtCLFNBQVMsWUFBWSxXQUFXO0FBQUEsUUFDNUUsWUFBWSxLQUFlO0FBQzFCLGlCQUFPLFNBQVUsWUFBbUMsTUFBaUI7QUFDcEUsbUJBQU8sSUFBSSxLQUFLLE1BQU0sU0FBUyxHQUFHLElBQUk7QUFBQSxVQUN2QztBQUFBLFFBQ0Q7QUFBQSxRQUNBLFlBQVksS0FBZTtBQUMxQixpQkFBTyxTQUNOLFFBQ0EsVUFDQSxVQUNBQyxPQUNBLFVBQ0csTUFDRjtBQUVELGtCQUFNLE1BQU0sVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLE9BQU8sWUFBWTtBQUN2RSxnQkFBSSxRQUFRLE1BQU07QUFDakIsa0JBQUksS0FBSyxNQUFNLFFBQVEsVUFBVSxJQUFJLE1BQU1BLE9BQU0sRUFBQyxRQUFPLElBQUksT0FBTSxHQUFHLEdBQUcsSUFBSTtBQUFBLFlBQzlFLE9BQU87QUFDTixrQkFBSSxLQUFLLE1BQU0sUUFBUSxVQUFVLFVBQVVBLE9BQU0sT0FBTyxHQUFHLElBQUk7QUFBQSxZQUNoRTtBQUFBLFVBQ0Q7QUFBQSxRQUNEO0FBQUEsTUFDRCxDQUFDO0FBQ0QsV0FBSyxTQUFTLFdBQVc7QUFHekIsd0JBQWtCLFFBQVE7QUFDMUIsd0JBQWtCLE9BQU87QUFFekIsV0FBSyxTQUFTLFdBQVk7QUFDekIsWUFBSSxDQUFDLGtCQUFrQjtBQUFTO0FBQ2hDLDBCQUFrQixRQUFRO0FBQzFCLDBCQUFrQixPQUFPO0FBQUEsTUFDMUIsQ0FBQztBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0Y7QUFBQSxFQUVBLFdBQVc7QUFBQSxFQUVYO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfdmlldyIsICJhcHAiLCAiZmlsZSIsICJwYXR0ZXJuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAib2JzZXJ2ZXIiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfdmlldyIsICJpbXBvcnRfc3RhdGUiLCAiYXBwIiwgImltcG9ydF9zdGF0ZSIsICJwYXRoIl0KfQo=
